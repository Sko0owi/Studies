
freertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003e  00800100  00002bd6  00002c6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002bd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068a  0080013e  0080013e  00002ca8  2**0
                  ALLOC
  3 .stab         00007a10  00000000  00000000  00002ca8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005147  00000000  00000000  0000a6b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000f7ff  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000f810  2**2
                  CONTENTS, READONLY
  7 .debug_info   000005f4  00000000  00000000  0000f850  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000005a2  00000000  00000000  0000fe44  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000001a  00000000  00000000  000103e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000208  00000000  00000000  00010400  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 5d 12 	jmp	0x24ba	; 0x24ba <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__vector_18>
      4c:	0c 94 2e 01 	jmp	0x25c	; 0x25c <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 ed       	ldi	r30, 0xD6	; 214
      7c:	fb e2       	ldi	r31, 0x2B	; 43
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ae 33       	cpi	r26, 0x3E	; 62
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ae e3       	ldi	r26, 0x3E	; 62
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a8 3c       	cpi	r26, 0xC8	; 200
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 60 12 	call	0x24c0	; 0x24c0 <main>
      9e:	0c 94 e9 15 	jmp	0x2bd2	; 0x2bd2 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vSerial>:
        vTaskDelay(500 / portTICK_PERIOD_MS);
    }
}
static void vSerial(void* pvParameters)
{
    uart_init();
      a6:	0e 94 89 00 	call	0x112	; 0x112 <uart_init>
    stdin = stdout = stderr = &uart_file;
      aa:	80 e0       	ldi	r24, 0x00	; 0
      ac:	91 e0       	ldi	r25, 0x01	; 1
      ae:	90 93 c7 07 	sts	0x07C7, r25	; 0x8007c7 <__iob+0x5>
      b2:	80 93 c6 07 	sts	0x07C6, r24	; 0x8007c6 <__iob+0x4>
      b6:	90 93 c5 07 	sts	0x07C5, r25	; 0x8007c5 <__iob+0x3>
      ba:	80 93 c4 07 	sts	0x07C4, r24	; 0x8007c4 <__iob+0x2>
      be:	90 93 c3 07 	sts	0x07C3, r25	; 0x8007c3 <__iob+0x1>
      c2:	80 93 c2 07 	sts	0x07C2, r24	; 0x8007c2 <__iob>

    for ( ;; )
    {
        puts("Hello World\r\n");
        input = getchar();
        printf("You wrote %c\r\n", input); 
      c6:	cc e1       	ldi	r28, 0x1C	; 28
      c8:	d1 e0       	ldi	r29, 0x01	; 1

    char input;

    for ( ;; )
    {
        puts("Hello World\r\n");
      ca:	8e e0       	ldi	r24, 0x0E	; 14
      cc:	91 e0       	ldi	r25, 0x01	; 1
      ce:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <puts>
        input = getchar();
      d2:	80 91 c2 07 	lds	r24, 0x07C2	; 0x8007c2 <__iob>
      d6:	90 91 c3 07 	lds	r25, 0x07C3	; 0x8007c3 <__iob+0x1>
      da:	0e 94 9d 12 	call	0x253a	; 0x253a <fgetc>
        printf("You wrote %c\r\n", input); 
      de:	28 2f       	mov	r18, r24
      e0:	08 2e       	mov	r0, r24
      e2:	00 0c       	add	r0, r0
      e4:	33 0b       	sbc	r19, r19
      e6:	3f 93       	push	r19
      e8:	8f 93       	push	r24
      ea:	df 93       	push	r29
      ec:	cf 93       	push	r28
      ee:	0e 94 db 12 	call	0x25b6	; 0x25b6 <printf>
      f2:	0f 90       	pop	r0
      f4:	0f 90       	pop	r0
      f6:	0f 90       	pop	r0
      f8:	0f 90       	pop	r0
      fa:	e7 cf       	rjmp	.-50     	; 0xca <vSerial+0x24>

000000fc <vBlinkLed>:
    return 0;
}
void vApplicationIdleHook(void){}
static void vBlinkLed(void* pvParameters)
{
    DDRB |= _BV(PB5);
      fc:	25 9a       	sbi	0x04, 5	; 4

    for ( ;; )
    {
        PORTB ^= _BV(PB5);
      fe:	c0 e2       	ldi	r28, 0x20	; 32
     100:	85 b1       	in	r24, 0x05	; 5
     102:	8c 27       	eor	r24, r28
     104:	85 b9       	out	0x05, r24	; 5
        vTaskDelay(500 / portTICK_PERIOD_MS);
     106:	84 ef       	ldi	r24, 0xF4	; 244
     108:	91 e0       	ldi	r25, 0x01	; 1
     10a:	0e 94 a0 05 	call	0xb40	; 0xb40 <vTaskDelay>
     10e:	f8 cf       	rjmp	.-16     	; 0x100 <vBlinkLed+0x4>

00000110 <vApplicationIdleHook>:
    // Start scheduler.
    vTaskStartScheduler();

    return 0;
}
void vApplicationIdleHook(void){}
     110:	08 95       	ret

00000112 <uart_init>:
#define QUEUE_SIZE 128
xQueueHandle recvQueue, sendQueue;

void uart_init()
{ 
  UBRR0H = UBRRH_VALUE;
     112:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
  UBRR0L = UBRRL_VALUE;
     116:	87 e6       	ldi	r24, 0x67	; 103
     118:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
#if USE_2X
    UCSR0A |= _BV(U2X0);
#else
    UCSR0A &= ~(_BV(U2X0));
     11c:	e0 ec       	ldi	r30, 0xC0	; 192
     11e:	f0 e0       	ldi	r31, 0x00	; 0
     120:	80 81       	ld	r24, Z
     122:	8d 7f       	andi	r24, 0xFD	; 253
     124:	80 83       	st	Z, r24
#endif
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data */
     126:	86 e0       	ldi	r24, 0x06	; 6
     128:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
  UCSR0B = _BV(RXEN0) | _BV(TXEN0); /* Enable RX and TX */  
     12c:	e1 ec       	ldi	r30, 0xC1	; 193
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	88 e1       	ldi	r24, 0x18	; 24
     132:	80 83       	st	Z, r24
  UCSR0B |= _BV(RXCIE0);
     134:	80 81       	ld	r24, Z
     136:	80 68       	ori	r24, 0x80	; 128
     138:	80 83       	st	Z, r24
  recvQueue = xQueueCreate(QUEUE_SIZE, sizeof(char));
     13a:	40 e0       	ldi	r20, 0x00	; 0
     13c:	61 e0       	ldi	r22, 0x01	; 1
     13e:	80 e8       	ldi	r24, 0x80	; 128
     140:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <xQueueGenericCreate>
     144:	90 93 c1 07 	sts	0x07C1, r25	; 0x8007c1 <recvQueue+0x1>
     148:	80 93 c0 07 	sts	0x07C0, r24	; 0x8007c0 <recvQueue>
  sendQueue = xQueueCreate(QUEUE_SIZE, sizeof(char));
     14c:	40 e0       	ldi	r20, 0x00	; 0
     14e:	61 e0       	ldi	r22, 0x01	; 1
     150:	80 e8       	ldi	r24, 0x80	; 128
     152:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <xQueueGenericCreate>
     156:	90 93 bf 07 	sts	0x07BF, r25	; 0x8007bf <sendQueue+0x1>
     15a:	80 93 be 07 	sts	0x07BE, r24	; 0x8007be <sendQueue>
     15e:	08 95       	ret

00000160 <uart_transmit>:

}


int uart_transmit(char c, FILE *stream) {
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	1f 92       	push	r1
     166:	cd b7       	in	r28, 0x3d	; 61
     168:	de b7       	in	r29, 0x3e	; 62
     16a:	89 83       	std	Y+1, r24	; 0x01

  while((!uxQueueSpacesAvailable(sendQueue)));
     16c:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <sendQueue>
     170:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <sendQueue+0x1>
     174:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <uxQueueSpacesAvailable>
     178:	88 23       	and	r24, r24
     17a:	c1 f3       	breq	.-16     	; 0x16c <uart_transmit+0xc>
  
  xQueueSend(sendQueue, &c, 0);
     17c:	20 e0       	ldi	r18, 0x00	; 0
     17e:	40 e0       	ldi	r20, 0x00	; 0
     180:	50 e0       	ldi	r21, 0x00	; 0
     182:	be 01       	movw	r22, r28
     184:	6f 5f       	subi	r22, 0xFF	; 255
     186:	7f 4f       	sbci	r23, 0xFF	; 255
     188:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <sendQueue>
     18c:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <sendQueue+0x1>
     190:	0e 94 8b 0a 	call	0x1516	; 0x1516 <xQueueGenericSend>

  UCSR0B |= _BV(UDRIE0);
     194:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     198:	80 62       	ori	r24, 0x20	; 32
     19a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
  return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	90 e0       	ldi	r25, 0x00	; 0
     1a2:	0f 90       	pop	r0
     1a4:	df 91       	pop	r29
     1a6:	cf 91       	pop	r28
     1a8:	08 95       	ret

000001aa <uart_receive>:

int uart_receive(FILE *stream) {
     1aa:	cf 93       	push	r28
     1ac:	df 93       	push	r29
     1ae:	1f 92       	push	r1
     1b0:	cd b7       	in	r28, 0x3d	; 61
     1b2:	de b7       	in	r29, 0x3e	; 62

  while(!uxQueueMessagesWaiting(recvQueue));
     1b4:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <recvQueue>
     1b8:	90 91 c1 07 	lds	r25, 0x07C1	; 0x8007c1 <recvQueue+0x1>
     1bc:	0e 94 63 0d 	call	0x1ac6	; 0x1ac6 <uxQueueMessagesWaiting>
     1c0:	88 23       	and	r24, r24
     1c2:	c1 f3       	breq	.-16     	; 0x1b4 <uart_receive+0xa>
  char c;
  xQueueReceive(recvQueue, &c, 0);
     1c4:	40 e0       	ldi	r20, 0x00	; 0
     1c6:	50 e0       	ldi	r21, 0x00	; 0
     1c8:	be 01       	movw	r22, r28
     1ca:	6f 5f       	subi	r22, 0xFF	; 255
     1cc:	7f 4f       	sbci	r23, 0xFF	; 255
     1ce:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <recvQueue>
     1d2:	90 91 c1 07 	lds	r25, 0x07C1	; 0x8007c1 <recvQueue+0x1>
     1d6:	0e 94 73 0b 	call	0x16e6	; 0x16e6 <xQueueReceive>
  return c;
     1da:	89 81       	ldd	r24, Y+1	; 0x01
}
     1dc:	08 2e       	mov	r0, r24
     1de:	00 0c       	add	r0, r0
     1e0:	99 0b       	sbc	r25, r25
     1e2:	0f 90       	pop	r0
     1e4:	df 91       	pop	r29
     1e6:	cf 91       	pop	r28
     1e8:	08 95       	ret

000001ea <__vector_18>:

ISR(USART_RX_vect) {
     1ea:	1f 92       	push	r1
     1ec:	0f 92       	push	r0
     1ee:	0f b6       	in	r0, 0x3f	; 63
     1f0:	0f 92       	push	r0
     1f2:	11 24       	eor	r1, r1
     1f4:	2f 93       	push	r18
     1f6:	3f 93       	push	r19
     1f8:	4f 93       	push	r20
     1fa:	5f 93       	push	r21
     1fc:	6f 93       	push	r22
     1fe:	7f 93       	push	r23
     200:	8f 93       	push	r24
     202:	9f 93       	push	r25
     204:	af 93       	push	r26
     206:	bf 93       	push	r27
     208:	ef 93       	push	r30
     20a:	ff 93       	push	r31
     20c:	cf 93       	push	r28
     20e:	df 93       	push	r29
     210:	1f 92       	push	r1
     212:	cd b7       	in	r28, 0x3d	; 61
     214:	de b7       	in	r29, 0x3e	; 62

  char c = UDR0;
     216:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
     21a:	89 83       	std	Y+1, r24	; 0x01
  xQueueSendToBackFromISR(recvQueue, &c, NULL);
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	40 e0       	ldi	r20, 0x00	; 0
     220:	50 e0       	ldi	r21, 0x00	; 0
     222:	be 01       	movw	r22, r28
     224:	6f 5f       	subi	r22, 0xFF	; 255
     226:	7f 4f       	sbci	r23, 0xFF	; 255
     228:	80 91 c0 07 	lds	r24, 0x07C0	; 0x8007c0 <recvQueue>
     22c:	90 91 c1 07 	lds	r25, 0x07C1	; 0x8007c1 <recvQueue+0x1>
     230:	0e 94 21 0b 	call	0x1642	; 0x1642 <xQueueGenericSendFromISR>
  
}
     234:	0f 90       	pop	r0
     236:	df 91       	pop	r29
     238:	cf 91       	pop	r28
     23a:	ff 91       	pop	r31
     23c:	ef 91       	pop	r30
     23e:	bf 91       	pop	r27
     240:	af 91       	pop	r26
     242:	9f 91       	pop	r25
     244:	8f 91       	pop	r24
     246:	7f 91       	pop	r23
     248:	6f 91       	pop	r22
     24a:	5f 91       	pop	r21
     24c:	4f 91       	pop	r20
     24e:	3f 91       	pop	r19
     250:	2f 91       	pop	r18
     252:	0f 90       	pop	r0
     254:	0f be       	out	0x3f, r0	; 63
     256:	0f 90       	pop	r0
     258:	1f 90       	pop	r1
     25a:	18 95       	reti

0000025c <__vector_19>:

ISR(USART_UDRE_vect) {
     25c:	1f 92       	push	r1
     25e:	0f 92       	push	r0
     260:	0f b6       	in	r0, 0x3f	; 63
     262:	0f 92       	push	r0
     264:	11 24       	eor	r1, r1
     266:	2f 93       	push	r18
     268:	3f 93       	push	r19
     26a:	4f 93       	push	r20
     26c:	5f 93       	push	r21
     26e:	6f 93       	push	r22
     270:	7f 93       	push	r23
     272:	8f 93       	push	r24
     274:	9f 93       	push	r25
     276:	af 93       	push	r26
     278:	bf 93       	push	r27
     27a:	ef 93       	push	r30
     27c:	ff 93       	push	r31
     27e:	cf 93       	push	r28
     280:	df 93       	push	r29
     282:	1f 92       	push	r1
     284:	cd b7       	in	r28, 0x3d	; 61
     286:	de b7       	in	r29, 0x3e	; 62

  if (!uxQueueMessagesWaitingFromISR(sendQueue))
     288:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <sendQueue>
     28c:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <sendQueue+0x1>
     290:	0e 94 75 0d 	call	0x1aea	; 0x1aea <uxQueueMessagesWaitingFromISR>
     294:	81 11       	cpse	r24, r1
     296:	06 c0       	rjmp	.+12     	; 0x2a4 <__vector_19+0x48>
    UCSR0B &= ~_BV(UDRIE0);
     298:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     29c:	8f 7d       	andi	r24, 0xDF	; 223
     29e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
     2a2:	0e c0       	rjmp	.+28     	; 0x2c0 <__vector_19+0x64>
  else 
  {
    char c;
    xQueueReceiveFromISR(sendQueue, &c, NULL);
     2a4:	40 e0       	ldi	r20, 0x00	; 0
     2a6:	50 e0       	ldi	r21, 0x00	; 0
     2a8:	be 01       	movw	r22, r28
     2aa:	6f 5f       	subi	r22, 0xFF	; 255
     2ac:	7f 4f       	sbci	r23, 0xFF	; 255
     2ae:	80 91 be 07 	lds	r24, 0x07BE	; 0x8007be <sendQueue>
     2b2:	90 91 bf 07 	lds	r25, 0x07BF	; 0x8007bf <sendQueue+0x1>
     2b6:	0e 94 1d 0d 	call	0x1a3a	; 0x1a3a <xQueueReceiveFromISR>
    UDR0 = c;
     2ba:	89 81       	ldd	r24, Y+1	; 0x01
     2bc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
  }
  
}
     2c0:	0f 90       	pop	r0
     2c2:	df 91       	pop	r29
     2c4:	cf 91       	pop	r28
     2c6:	ff 91       	pop	r31
     2c8:	ef 91       	pop	r30
     2ca:	bf 91       	pop	r27
     2cc:	af 91       	pop	r26
     2ce:	9f 91       	pop	r25
     2d0:	8f 91       	pop	r24
     2d2:	7f 91       	pop	r23
     2d4:	6f 91       	pop	r22
     2d6:	5f 91       	pop	r21
     2d8:	4f 91       	pop	r20
     2da:	3f 91       	pop	r19
     2dc:	2f 91       	pop	r18
     2de:	0f 90       	pop	r0
     2e0:	0f be       	out	0x3f, r0	; 63
     2e2:	0f 90       	pop	r0
     2e4:	1f 90       	pop	r1
     2e6:	18 95       	reti

000002e8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     2e8:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     2ec:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     2f0:	80 81       	ld	r24, Z
     2f2:	81 11       	cpse	r24, r1
     2f4:	03 c0       	rjmp	.+6      	; 0x2fc <prvResetNextTaskUnblockTime+0x14>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     2f6:	8f ef       	ldi	r24, 0xFF	; 255
     2f8:	9f ef       	ldi	r25, 0xFF	; 255
     2fa:	0c c0       	rjmp	.+24     	; 0x314 <prvResetNextTaskUnblockTime+0x2c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     2fc:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     300:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     304:	05 80       	ldd	r0, Z+5	; 0x05
     306:	f6 81       	ldd	r31, Z+6	; 0x06
     308:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
     30a:	06 80       	ldd	r0, Z+6	; 0x06
     30c:	f7 81       	ldd	r31, Z+7	; 0x07
     30e:	e0 2d       	mov	r30, r0
     310:	82 81       	ldd	r24, Z+2	; 0x02
     312:	93 81       	ldd	r25, Z+3	; 0x03
     314:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
     318:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
     31c:	08 95       	ret

0000031e <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
     31e:	ff 92       	push	r15
     320:	0f 93       	push	r16
     322:	1f 93       	push	r17
     324:	cf 93       	push	r28
     326:	df 93       	push	r29
     328:	ec 01       	movw	r28, r24
     32a:	f6 2e       	mov	r15, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
     32c:	00 91 4b 01 	lds	r16, 0x014B	; 0x80014b <xTickCount>
     330:	10 91 4c 01 	lds	r17, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     334:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     338:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     33c:	02 96       	adiw	r24, 0x02	; 2
     33e:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
     342:	cf 3f       	cpi	r28, 0xFF	; 255
     344:	8f ef       	ldi	r24, 0xFF	; 255
     346:	d8 07       	cpc	r29, r24
     348:	89 f4       	brne	.+34     	; 0x36c <prvAddCurrentTaskToDelayedList+0x4e>
     34a:	ff 20       	and	r15, r15
     34c:	79 f0       	breq	.+30     	; 0x36c <prvAddCurrentTaskToDelayedList+0x4e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     34e:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     352:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     356:	6e 5f       	subi	r22, 0xFE	; 254
     358:	7f 4f       	sbci	r23, 0xFF	; 255
     35a:	8e e4       	ldi	r24, 0x4E	; 78
     35c:	91 e0       	ldi	r25, 0x01	; 1

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	1f 91       	pop	r17
     364:	0f 91       	pop	r16
     366:	ff 90       	pop	r15
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
     368:	0c 94 77 0e 	jmp	0x1cee	; 0x1cee <vListInsertEnd>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
     36c:	c0 0f       	add	r28, r16
     36e:	d1 1f       	adc	r29, r17

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
     370:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     374:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     378:	d3 83       	std	Z+3, r29	; 0x03
     37a:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     37c:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     380:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );

			if( xTimeToWake < xConstTickCount )
     384:	c0 17       	cp	r28, r16
     386:	d1 07       	cpc	r29, r17
     388:	68 f4       	brcc	.+26     	; 0x3a4 <prvAddCurrentTaskToDelayedList+0x86>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     38a:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <pxOverflowDelayedTaskList>
     38e:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     392:	6e 5f       	subi	r22, 0xFE	; 254
     394:	7f 4f       	sbci	r23, 0xFF	; 255

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     396:	df 91       	pop	r29
     398:	cf 91       	pop	r28
     39a:	1f 91       	pop	r17
     39c:	0f 91       	pop	r16
     39e:	ff 90       	pop	r15

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     3a0:	0c 94 98 0e 	jmp	0x1d30	; 0x1d30 <vListInsert>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
     3a4:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <pxDelayedTaskList>
     3a8:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     3ac:	6e 5f       	subi	r22, 0xFE	; 254
     3ae:	7f 4f       	sbci	r23, 0xFF	; 255
     3b0:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
     3b4:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
     3b8:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
     3bc:	c8 17       	cp	r28, r24
     3be:	d9 07       	cpc	r29, r25
     3c0:	20 f4       	brcc	.+8      	; 0x3ca <prvAddCurrentTaskToDelayedList+0xac>
				{
					xNextTaskUnblockTime = xTimeToWake;
     3c2:	d0 93 44 01 	sts	0x0144, r29	; 0x800144 <xNextTaskUnblockTime+0x1>
     3c6:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <xNextTaskUnblockTime>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     3ca:	df 91       	pop	r29
     3cc:	cf 91       	pop	r28
     3ce:	1f 91       	pop	r17
     3d0:	0f 91       	pop	r16
     3d2:	ff 90       	pop	r15
     3d4:	08 95       	ret

000003d6 <prvIdleTask>:
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     3d6:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     3da:	88 23       	and	r24, r24
     3dc:	09 f1       	breq	.+66     	; 0x420 <__EEPROM_REGION_LENGTH__+0x20>
		{
			taskENTER_CRITICAL();
     3de:	0f b6       	in	r0, 0x3f	; 63
     3e0:	f8 94       	cli
     3e2:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     3e4:	e0 91 5d 01 	lds	r30, 0x015D	; 0x80015d <xTasksWaitingTermination+0x5>
     3e8:	f0 91 5e 01 	lds	r31, 0x015E	; 0x80015e <xTasksWaitingTermination+0x6>
     3ec:	c6 81       	ldd	r28, Z+6	; 0x06
     3ee:	d7 81       	ldd	r29, Z+7	; 0x07
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     3f0:	ce 01       	movw	r24, r28
     3f2:	02 96       	adiw	r24, 0x02	; 2
     3f4:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
				--uxCurrentNumberOfTasks;
     3f8:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     3fc:	81 50       	subi	r24, 0x01	; 1
     3fe:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>
				--uxDeletedTasksWaitingCleanUp;
     402:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     406:	81 50       	subi	r24, 0x01	; 1
     408:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <uxDeletedTasksWaitingCleanUp>
			}
			taskEXIT_CRITICAL();
     40c:	0f 90       	pop	r0
     40e:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     410:	8f 89       	ldd	r24, Y+23	; 0x17
     412:	98 8d       	ldd	r25, Y+24	; 0x18
     414:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vPortFree>
			vPortFree( pxTCB );
     418:	ce 01       	movw	r24, r28
     41a:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vPortFree>
     41e:	db cf       	rjmp	.-74     	; 0x3d6 <prvIdleTask>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     420:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <pxReadyTasksLists>
     424:	82 30       	cpi	r24, 0x02	; 2
     426:	10 f0       	brcs	.+4      	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
			{
				taskYIELD();
     428:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     42c:	0e 94 88 00 	call	0x110	; 0x110 <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     430:	d2 cf       	rjmp	.-92     	; 0x3d6 <prvIdleTask>

00000432 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
     432:	3f 92       	push	r3
     434:	4f 92       	push	r4
     436:	5f 92       	push	r5
     438:	6f 92       	push	r6
     43a:	7f 92       	push	r7
     43c:	8f 92       	push	r8
     43e:	9f 92       	push	r9
     440:	af 92       	push	r10
     442:	bf 92       	push	r11
     444:	cf 92       	push	r12
     446:	df 92       	push	r13
     448:	ef 92       	push	r14
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	4c 01       	movw	r8, r24
     456:	16 2f       	mov	r17, r22
     458:	37 2e       	mov	r3, r23
     45a:	6a 01       	movw	r12, r20
     45c:	59 01       	movw	r10, r18
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
     45e:	ca 01       	movw	r24, r20
     460:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
     464:	2c 01       	movw	r4, r24

			if( pxStack != NULL )
     466:	89 2b       	or	r24, r25
     468:	09 f4       	brne	.+2      	; 0x46c <xTaskCreate+0x3a>
     46a:	d1 c0       	rjmp	.+418    	; 0x60e <xTaskCreate+0x1dc>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
     46c:	86 e2       	ldi	r24, 0x26	; 38
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
     474:	ec 01       	movw	r28, r24

				if( pxNewTCB != NULL )
     476:	89 2b       	or	r24, r25
     478:	79 f0       	breq	.+30     	; 0x498 <xTaskCreate+0x66>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
     47a:	58 8e       	std	Y+24, r5	; 0x18
     47c:	4f 8a       	std	Y+23, r4	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
     47e:	c6 01       	movw	r24, r12
     480:	01 97       	sbiw	r24, 0x01	; 1
     482:	32 01       	movw	r6, r4
     484:	68 0e       	add	r6, r24
     486:	79 1e       	adc	r7, r25
     488:	be 01       	movw	r22, r28
     48a:	67 5e       	subi	r22, 0xE7	; 231
     48c:	7f 4f       	sbci	r23, 0xFF	; 255
     48e:	e1 2f       	mov	r30, r17
     490:	f3 2d       	mov	r31, r3
     492:	cf 01       	movw	r24, r30
     494:	08 96       	adiw	r24, 0x08	; 8
     496:	07 c0       	rjmp	.+14     	; 0x4a6 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
     498:	c2 01       	movw	r24, r4
     49a:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vPortFree>
     49e:	b7 c0       	rjmp	.+366    	; 0x60e <xTaskCreate+0x1dc>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     4a0:	e8 17       	cp	r30, r24
     4a2:	f9 07       	cpc	r31, r25
     4a4:	49 f0       	breq	.+18     	; 0x4b8 <xTaskCreate+0x86>
     4a6:	9f 01       	movw	r18, r30
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     4a8:	41 91       	ld	r20, Z+
     4aa:	db 01       	movw	r26, r22
     4ac:	4d 93       	st	X+, r20
     4ae:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
     4b0:	d9 01       	movw	r26, r18
     4b2:	2c 91       	ld	r18, X
     4b4:	21 11       	cpse	r18, r1
     4b6:	f4 cf       	rjmp	.-24     	; 0x4a0 <xTaskCreate+0x6e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     4b8:	18 a2       	std	Y+32, r1	; 0x20
     4ba:	04 30       	cpi	r16, 0x04	; 4
     4bc:	08 f0       	brcs	.+2      	; 0x4c0 <xTaskCreate+0x8e>
     4be:	03 e0       	ldi	r16, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
     4c0:	0e 8b       	std	Y+22, r16	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     4c2:	6e 01       	movw	r12, r28
     4c4:	b2 e0       	ldi	r27, 0x02	; 2
     4c6:	cb 0e       	add	r12, r27
     4c8:	d1 1c       	adc	r13, r1
     4ca:	c6 01       	movw	r24, r12
     4cc:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     4d0:	ce 01       	movw	r24, r28
     4d2:	0c 96       	adiw	r24, 0x0c	; 12
     4d4:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     4d8:	d9 87       	std	Y+9, r29	; 0x09
     4da:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     4dc:	84 e0       	ldi	r24, 0x04	; 4
     4de:	90 e0       	ldi	r25, 0x00	; 0
     4e0:	80 1b       	sub	r24, r16
     4e2:	91 09       	sbc	r25, r1
     4e4:	9d 87       	std	Y+13, r25	; 0x0d
     4e6:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     4e8:	db 8b       	std	Y+19, r29	; 0x13
     4ea:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
     4ec:	19 a2       	std	Y+33, r1	; 0x21
     4ee:	1a a2       	std	Y+34, r1	; 0x22
     4f0:	1b a2       	std	Y+35, r1	; 0x23
     4f2:	1c a2       	std	Y+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     4f4:	1d a2       	std	Y+37, r1	; 0x25
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     4f6:	a5 01       	movw	r20, r10
     4f8:	b4 01       	movw	r22, r8
     4fa:	c3 01       	movw	r24, r6
     4fc:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <pxPortInitialiseStack>
     500:	99 83       	std	Y+1, r25	; 0x01
     502:	88 83       	st	Y, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
     504:	e1 14       	cp	r14, r1
     506:	f1 04       	cpc	r15, r1
     508:	19 f0       	breq	.+6      	; 0x510 <xTaskCreate+0xde>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     50a:	f7 01       	movw	r30, r14
     50c:	d1 83       	std	Z+1, r29	; 0x01
     50e:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
     510:	0f b6       	in	r0, 0x3f	; 63
     512:	f8 94       	cli
     514:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
     516:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     51a:	8f 5f       	subi	r24, 0xFF	; 255
     51c:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>
		if( pxCurrentTCB == NULL )
     520:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     524:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     528:	89 2b       	or	r24, r25
     52a:	d1 f5       	brne	.+116    	; 0x5a0 <xTaskCreate+0x16e>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
     52c:	d0 93 3f 01 	sts	0x013F, r29	; 0x80013f <__data_end+0x1>
     530:	c0 93 3e 01 	sts	0x013E, r28	; 0x80013e <__data_end>

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     534:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     538:	81 30       	cpi	r24, 0x01	; 1
     53a:	09 f0       	breq	.+2      	; 0x53e <xTaskCreate+0x10c>
     53c:	41 c0       	rjmp	.+130    	; 0x5c0 <xTaskCreate+0x18e>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     53e:	80 e8       	ldi	r24, 0x80	; 128
     540:	91 e0       	ldi	r25, 0x01	; 1
     542:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
     546:	89 e8       	ldi	r24, 0x89	; 137
     548:	91 e0       	ldi	r25, 0x01	; 1
     54a:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
     54e:	82 e9       	ldi	r24, 0x92	; 146
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
     556:	8b e9       	ldi	r24, 0x9B	; 155
     558:	91 e0       	ldi	r25, 0x01	; 1
     55a:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     55e:	87 e7       	ldi	r24, 0x77	; 119
     560:	91 e0       	ldi	r25, 0x01	; 1
     562:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     566:	8e e6       	ldi	r24, 0x6E	; 110
     568:	91 e0       	ldi	r25, 0x01	; 1
     56a:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	vListInitialise( &xPendingReadyList );
     56e:	81 e6       	ldi	r24, 0x61	; 97
     570:	91 e0       	ldi	r25, 0x01	; 1
     572:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     576:	88 e5       	ldi	r24, 0x58	; 88
     578:	91 e0       	ldi	r25, 0x01	; 1
     57a:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     57e:	8e e4       	ldi	r24, 0x4E	; 78
     580:	91 e0       	ldi	r25, 0x01	; 1
     582:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     586:	87 e7       	ldi	r24, 0x77	; 119
     588:	91 e0       	ldi	r25, 0x01	; 1
     58a:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <pxDelayedTaskList+0x1>
     58e:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <pxDelayedTaskList>
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     592:	8e e6       	ldi	r24, 0x6E	; 110
     594:	91 e0       	ldi	r25, 0x01	; 1
     596:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     59a:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <pxOverflowDelayedTaskList>
     59e:	10 c0       	rjmp	.+32     	; 0x5c0 <xTaskCreate+0x18e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
     5a0:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     5a4:	81 11       	cpse	r24, r1
     5a6:	0c c0       	rjmp	.+24     	; 0x5c0 <xTaskCreate+0x18e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     5a8:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     5ac:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     5b0:	96 89       	ldd	r25, Z+22	; 0x16
     5b2:	8e 89       	ldd	r24, Y+22	; 0x16
     5b4:	89 17       	cp	r24, r25
     5b6:	20 f0       	brcs	.+8      	; 0x5c0 <xTaskCreate+0x18e>
				{
					pxCurrentTCB = pxNewTCB;
     5b8:	d0 93 3f 01 	sts	0x013F, r29	; 0x80013f <__data_end+0x1>
     5bc:	c0 93 3e 01 	sts	0x013E, r28	; 0x80013e <__data_end>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
     5c0:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uxTaskNumber>
     5c4:	8f 5f       	subi	r24, 0xFF	; 255
     5c6:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uxTaskNumber>
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
     5ca:	8e 89       	ldd	r24, Y+22	; 0x16
     5cc:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     5d0:	98 17       	cp	r25, r24
     5d2:	10 f4       	brcc	.+4      	; 0x5d8 <xTaskCreate+0x1a6>
     5d4:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     5d8:	f9 e0       	ldi	r31, 0x09	; 9
     5da:	8f 9f       	mul	r24, r31
     5dc:	c0 01       	movw	r24, r0
     5de:	11 24       	eor	r1, r1
     5e0:	b6 01       	movw	r22, r12
     5e2:	80 58       	subi	r24, 0x80	; 128
     5e4:	9e 4f       	sbci	r25, 0xFE	; 254
     5e6:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
     5ea:	0f 90       	pop	r0
     5ec:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
     5ee:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     5f2:	88 23       	and	r24, r24
     5f4:	51 f0       	breq	.+20     	; 0x60a <xTaskCreate+0x1d8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
     5f6:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     5fa:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     5fe:	96 89       	ldd	r25, Z+22	; 0x16
     600:	8e 89       	ldd	r24, Y+22	; 0x16
     602:	98 17       	cp	r25, r24
     604:	10 f4       	brcc	.+4      	; 0x60a <xTaskCreate+0x1d8>
		{
			taskYIELD_IF_USING_PREEMPTION();
     606:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	01 c0       	rjmp	.+2      	; 0x610 <xTaskCreate+0x1de>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     60e:	8f ef       	ldi	r24, 0xFF	; 255
		}

		return xReturn;
	}
     610:	df 91       	pop	r29
     612:	cf 91       	pop	r28
     614:	1f 91       	pop	r17
     616:	0f 91       	pop	r16
     618:	ff 90       	pop	r15
     61a:	ef 90       	pop	r14
     61c:	df 90       	pop	r13
     61e:	cf 90       	pop	r12
     620:	bf 90       	pop	r11
     622:	af 90       	pop	r10
     624:	9f 90       	pop	r9
     626:	8f 90       	pop	r8
     628:	7f 90       	pop	r7
     62a:	6f 90       	pop	r6
     62c:	5f 90       	pop	r5
     62e:	4f 90       	pop	r4
     630:	3f 90       	pop	r3
     632:	08 95       	ret

00000634 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
     634:	0f 93       	push	r16
     636:	1f 93       	push	r17
     638:	cf 93       	push	r28
     63a:	df 93       	push	r29
     63c:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     63e:	0f b6       	in	r0, 0x3f	; 63
     640:	f8 94       	cli
     642:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     644:	89 2b       	or	r24, r25
     646:	21 f4       	brne	.+8      	; 0x650 <vTaskDelete+0x1c>
     648:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <__data_end>
     64c:	d0 91 3f 01 	lds	r29, 0x013F	; 0x80013f <__data_end+0x1>

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     650:	8e 01       	movw	r16, r28
     652:	0e 5f       	subi	r16, 0xFE	; 254
     654:	1f 4f       	sbci	r17, 0xFF	; 255
     656:	c8 01       	movw	r24, r16
     658:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     65c:	8c 89       	ldd	r24, Y+20	; 0x14
     65e:	9d 89       	ldd	r25, Y+21	; 0x15
     660:	89 2b       	or	r24, r25
     662:	21 f0       	breq	.+8      	; 0x66c <vTaskDelete+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     664:	ce 01       	movw	r24, r28
     666:	0c 96       	adiw	r24, 0x0c	; 12
     668:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
     66c:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <uxTaskNumber>
     670:	8f 5f       	subi	r24, 0xFF	; 255
     672:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <uxTaskNumber>

			if( pxTCB == pxCurrentTCB )
     676:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     67a:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     67e:	c8 17       	cp	r28, r24
     680:	d9 07       	cpc	r29, r25
     682:	59 f4       	brne	.+22     	; 0x69a <vTaskDelete+0x66>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
     684:	b8 01       	movw	r22, r16
     686:	88 e5       	ldi	r24, 0x58	; 88
     688:	91 e0       	ldi	r25, 0x01	; 1
     68a:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
     68e:	80 91 57 01 	lds	r24, 0x0157	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     692:	8f 5f       	subi	r24, 0xFF	; 255
     694:	80 93 57 01 	sts	0x0157, r24	; 0x800157 <uxDeletedTasksWaitingCleanUp>
     698:	0e c0       	rjmp	.+28     	; 0x6b6 <vTaskDelete+0x82>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
     69a:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     69e:	81 50       	subi	r24, 0x01	; 1
     6a0:	80 93 4d 01 	sts	0x014D, r24	; 0x80014d <uxCurrentNumberOfTasks>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     6a4:	8f 89       	ldd	r24, Y+23	; 0x17
     6a6:	98 8d       	ldd	r25, Y+24	; 0x18
     6a8:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vPortFree>
			vPortFree( pxTCB );
     6ac:	ce 01       	movw	r24, r28
     6ae:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <vPortFree>
				--uxCurrentNumberOfTasks;
				prvDeleteTCB( pxTCB );

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
     6b2:	0e 94 74 01 	call	0x2e8	; 0x2e8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     6b6:	0f 90       	pop	r0
     6b8:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
     6ba:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     6be:	88 23       	and	r24, r24
     6c0:	49 f0       	breq	.+18     	; 0x6d4 <vTaskDelete+0xa0>
		{
			if( pxTCB == pxCurrentTCB )
     6c2:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     6c6:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     6ca:	c8 17       	cp	r28, r24
     6cc:	d9 07       	cpc	r29, r25
     6ce:	11 f4       	brne	.+4      	; 0x6d4 <vTaskDelete+0xa0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     6d0:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
     6d4:	df 91       	pop	r29
     6d6:	cf 91       	pop	r28
     6d8:	1f 91       	pop	r17
     6da:	0f 91       	pop	r16
     6dc:	08 95       	ret

000006de <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
     6de:	0f 93       	push	r16
     6e0:	1f 93       	push	r17
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
     6e6:	20 91 3e 01 	lds	r18, 0x013E	; 0x80013e <__data_end>
     6ea:	30 91 3f 01 	lds	r19, 0x013F	; 0x80013f <__data_end+0x1>
     6ee:	82 17       	cp	r24, r18
     6f0:	93 07       	cpc	r25, r19
     6f2:	b9 f1       	breq	.+110    	; 0x762 <vTaskResume+0x84>
     6f4:	00 97       	sbiw	r24, 0x00	; 0
     6f6:	a9 f1       	breq	.+106    	; 0x762 <vTaskResume+0x84>
		{
			taskENTER_CRITICAL();
     6f8:	0f b6       	in	r0, 0x3f	; 63
     6fa:	f8 94       	cli
     6fc:	0f 92       	push	r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     6fe:	fc 01       	movw	r30, r24
     700:	22 85       	ldd	r18, Z+10	; 0x0a
     702:	33 85       	ldd	r19, Z+11	; 0x0b
     704:	2e 54       	subi	r18, 0x4E	; 78
     706:	31 40       	sbci	r19, 0x01	; 1
     708:	51 f5       	brne	.+84     	; 0x75e <vTaskResume+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     70a:	fc 01       	movw	r30, r24
     70c:	24 89       	ldd	r18, Z+20	; 0x14
     70e:	35 89       	ldd	r19, Z+21	; 0x15
     710:	f1 e0       	ldi	r31, 0x01	; 1
     712:	21 36       	cpi	r18, 0x61	; 97
     714:	3f 07       	cpc	r19, r31
     716:	19 f1       	breq	.+70     	; 0x75e <vTaskResume+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     718:	23 2b       	or	r18, r19
     71a:	09 f5       	brne	.+66     	; 0x75e <vTaskResume+0x80>
     71c:	ec 01       	movw	r28, r24
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
     71e:	8c 01       	movw	r16, r24
     720:	0e 5f       	subi	r16, 0xFE	; 254
     722:	1f 4f       	sbci	r17, 0xFF	; 255
     724:	c8 01       	movw	r24, r16
     726:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     72a:	8e 89       	ldd	r24, Y+22	; 0x16
     72c:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     730:	98 17       	cp	r25, r24
     732:	10 f4       	brcc	.+4      	; 0x738 <vTaskResume+0x5a>
     734:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     738:	29 e0       	ldi	r18, 0x09	; 9
     73a:	82 9f       	mul	r24, r18
     73c:	c0 01       	movw	r24, r0
     73e:	11 24       	eor	r1, r1
     740:	b8 01       	movw	r22, r16
     742:	80 58       	subi	r24, 0x80	; 128
     744:	9e 4f       	sbci	r25, 0xFE	; 254
     746:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     74a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     74e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     752:	9e 89       	ldd	r25, Y+22	; 0x16
     754:	86 89       	ldd	r24, Z+22	; 0x16
     756:	98 17       	cp	r25, r24
     758:	10 f0       	brcs	.+4      	; 0x75e <vTaskResume+0x80>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
     75a:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     75e:	0f 90       	pop	r0
     760:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     762:	df 91       	pop	r29
     764:	cf 91       	pop	r28
     766:	1f 91       	pop	r17
     768:	0f 91       	pop	r16
     76a:	08 95       	ret

0000076c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
     76c:	ef 92       	push	r14
     76e:	ff 92       	push	r15
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
     778:	8a 85       	ldd	r24, Y+10	; 0x0a
     77a:	9b 85       	ldd	r25, Y+11	; 0x0b
     77c:	8e 54       	subi	r24, 0x4E	; 78
     77e:	91 40       	sbci	r25, 0x01	; 1
     780:	99 f4       	brne	.+38     	; 0x7a8 <xTaskResumeFromISR+0x3c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
     782:	8c 89       	ldd	r24, Y+20	; 0x14
     784:	9d 89       	ldd	r25, Y+21	; 0x15
     786:	21 e0       	ldi	r18, 0x01	; 1
     788:	81 36       	cpi	r24, 0x61	; 97
     78a:	92 07       	cpc	r25, r18
     78c:	69 f0       	breq	.+26     	; 0x7a8 <xTaskResumeFromISR+0x3c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
     78e:	89 2b       	or	r24, r25
     790:	59 f4       	brne	.+22     	; 0x7a8 <xTaskResumeFromISR+0x3c>
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     792:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     796:	88 23       	and	r24, r24
     798:	49 f0       	breq	.+18     	; 0x7ac <xTaskResumeFromISR+0x40>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
     79a:	be 01       	movw	r22, r28
     79c:	64 5f       	subi	r22, 0xF4	; 244
     79e:	7f 4f       	sbci	r23, 0xFF	; 255
     7a0:	81 e6       	ldi	r24, 0x61	; 97
     7a2:	91 e0       	ldi	r25, 0x01	; 1
     7a4:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     7a8:	10 e0       	ldi	r17, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
     7aa:	21 c0       	rjmp	.+66     	; 0x7ee <xTaskResumeFromISR+0x82>
				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     7ac:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     7b0:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
     7b4:	11 e0       	ldi	r17, 0x01	; 1
     7b6:	9e 89       	ldd	r25, Y+22	; 0x16
     7b8:	86 89       	ldd	r24, Z+22	; 0x16
     7ba:	98 17       	cp	r25, r24
     7bc:	08 f4       	brcc	.+2      	; 0x7c0 <xTaskResumeFromISR+0x54>
     7be:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7c0:	7e 01       	movw	r14, r28
     7c2:	82 e0       	ldi	r24, 0x02	; 2
     7c4:	e8 0e       	add	r14, r24
     7c6:	f1 1c       	adc	r15, r1
     7c8:	c7 01       	movw	r24, r14
     7ca:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     7ce:	8e 89       	ldd	r24, Y+22	; 0x16
     7d0:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     7d4:	98 17       	cp	r25, r24
     7d6:	10 f4       	brcc	.+4      	; 0x7dc <xTaskResumeFromISR+0x70>
     7d8:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     7dc:	29 e0       	ldi	r18, 0x09	; 9
     7de:	82 9f       	mul	r24, r18
     7e0:	c0 01       	movw	r24, r0
     7e2:	11 24       	eor	r1, r1
     7e4:	b7 01       	movw	r22, r14
     7e6:	80 58       	subi	r24, 0x80	; 128
     7e8:	9e 4f       	sbci	r25, 0xFE	; 254
     7ea:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
     7ee:	81 2f       	mov	r24, r17
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	1f 91       	pop	r17
     7f6:	ff 90       	pop	r15
     7f8:	ef 90       	pop	r14
     7fa:	08 95       	ret

000007fc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
     802:	81 e4       	ldi	r24, 0x41	; 65
     804:	e8 2e       	mov	r14, r24
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	f8 2e       	mov	r15, r24
     80a:	00 e0       	ldi	r16, 0x00	; 0
     80c:	20 e0       	ldi	r18, 0x00	; 0
     80e:	30 e0       	ldi	r19, 0x00	; 0
     810:	45 e5       	ldi	r20, 0x55	; 85
     812:	50 e0       	ldi	r21, 0x00	; 0
     814:	68 e3       	ldi	r22, 0x38	; 56
     816:	71 e0       	ldi	r23, 0x01	; 1
     818:	8b ee       	ldi	r24, 0xEB	; 235
     81a:	91 e0       	ldi	r25, 0x01	; 1
     81c:	0e 94 19 02 	call	0x432	; 0x432 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     820:	81 30       	cpi	r24, 0x01	; 1
     822:	91 f4       	brne	.+36     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     824:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     826:	2f ef       	ldi	r18, 0xFF	; 255
     828:	3f ef       	ldi	r19, 0xFF	; 255
     82a:	30 93 44 01 	sts	0x0144, r19	; 0x800144 <xNextTaskUnblockTime+0x1>
     82e:	20 93 43 01 	sts	0x0143, r18	; 0x800143 <xNextTaskUnblockTime>
		xSchedulerRunning = pdTRUE;
     832:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <xSchedulerRunning>
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     836:	10 92 4c 01 	sts	0x014C, r1	; 0x80014c <xTickCount+0x1>
     83a:	10 92 4b 01 	sts	0x014B, r1	; 0x80014b <xTickCount>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     83e:	0f 91       	pop	r16
     840:	ff 90       	pop	r15
     842:	ef 90       	pop	r14

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     844:	0c 94 67 11 	jmp	0x22ce	; 0x22ce <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	08 95       	ret

00000850 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     850:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     852:	10 92 49 01 	sts	0x0149, r1	; 0x800149 <xSchedulerRunning>
	vPortEndScheduler();
     856:	0c 94 a7 11 	jmp	0x234e	; 0x234e <vPortEndScheduler>

0000085a <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     85a:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     85e:	8f 5f       	subi	r24, 0xFF	; 255
     860:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxSchedulerSuspended>
     864:	08 95       	ret

00000866 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     866:	0f b6       	in	r0, 0x3f	; 63
     868:	f8 94       	cli
     86a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     86c:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <xTickCount>
     870:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	portTICK_TYPE_EXIT_CRITICAL();
     874:	0f 90       	pop	r0
     876:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     878:	08 95       	ret

0000087a <xTaskGetTickCountFromISR>:
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     87a:	80 91 4b 01 	lds	r24, 0x014B	; 0x80014b <xTickCount>
     87e:	90 91 4c 01 	lds	r25, 0x014C	; 0x80014c <xTickCount+0x1>
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     882:	08 95       	ret

00000884 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
     884:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
}
     888:	08 95       	ret

0000088a <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     88a:	00 97       	sbiw	r24, 0x00	; 0
     88c:	21 f4       	brne	.+8      	; 0x896 <pcTaskGetName+0xc>
     88e:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     892:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     896:	49 96       	adiw	r24, 0x19	; 25
     898:	08 95       	ret

0000089a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     89a:	cf 92       	push	r12
     89c:	df 92       	push	r13
     89e:	ef 92       	push	r14
     8a0:	ff 92       	push	r15
     8a2:	0f 93       	push	r16
     8a4:	1f 93       	push	r17
     8a6:	cf 93       	push	r28
     8a8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8aa:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     8ae:	81 11       	cpse	r24, r1
     8b0:	8c c0       	rjmp	.+280    	; 0x9ca <__stack+0xcb>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     8b2:	00 91 4b 01 	lds	r16, 0x014B	; 0x80014b <xTickCount>
     8b6:	10 91 4c 01 	lds	r17, 0x014C	; 0x80014c <xTickCount+0x1>
     8ba:	0f 5f       	subi	r16, 0xFF	; 255
     8bc:	1f 4f       	sbci	r17, 0xFF	; 255

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     8be:	10 93 4c 01 	sts	0x014C, r17	; 0x80014c <xTickCount+0x1>
     8c2:	00 93 4b 01 	sts	0x014B, r16	; 0x80014b <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
     8c6:	01 15       	cp	r16, r1
     8c8:	11 05       	cpc	r17, r1
     8ca:	b9 f4       	brne	.+46     	; 0x8fa <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     8cc:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <pxDelayedTaskList>
     8d0:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     8d4:	20 91 6a 01 	lds	r18, 0x016A	; 0x80016a <pxOverflowDelayedTaskList>
     8d8:	30 91 6b 01 	lds	r19, 0x016B	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     8dc:	30 93 6d 01 	sts	0x016D, r19	; 0x80016d <pxDelayedTaskList+0x1>
     8e0:	20 93 6c 01 	sts	0x016C, r18	; 0x80016c <pxDelayedTaskList>
     8e4:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <pxOverflowDelayedTaskList+0x1>
     8e8:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <pxOverflowDelayedTaskList>
     8ec:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <xNumOfOverflows>
     8f0:	8f 5f       	subi	r24, 0xFF	; 255
     8f2:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <xNumOfOverflows>
     8f6:	0e 94 74 01 	call	0x2e8	; 0x2e8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     8fa:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <xNextTaskUnblockTime>
     8fe:	90 91 44 01 	lds	r25, 0x0144	; 0x800144 <xNextTaskUnblockTime+0x1>
     902:	c0 e0       	ldi	r28, 0x00	; 0
     904:	08 17       	cp	r16, r24
     906:	19 07       	cpc	r17, r25
     908:	08 f4       	brcc	.+2      	; 0x90c <__stack+0xd>
     90a:	4f c0       	rjmp	.+158    	; 0x9aa <__stack+0xab>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     90c:	d9 e0       	ldi	r29, 0x09	; 9
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     90e:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     912:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     916:	80 81       	ld	r24, Z
     918:	81 11       	cpse	r24, r1
     91a:	03 c0       	rjmp	.+6      	; 0x922 <__stack+0x23>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     91c:	8f ef       	ldi	r24, 0xFF	; 255
     91e:	9f ef       	ldi	r25, 0xFF	; 255
     920:	11 c0       	rjmp	.+34     	; 0x944 <__stack+0x45>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     922:	e0 91 6c 01 	lds	r30, 0x016C	; 0x80016c <pxDelayedTaskList>
     926:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <pxDelayedTaskList+0x1>
     92a:	05 80       	ldd	r0, Z+5	; 0x05
     92c:	f6 81       	ldd	r31, Z+6	; 0x06
     92e:	e0 2d       	mov	r30, r0
     930:	e6 80       	ldd	r14, Z+6	; 0x06
     932:	f7 80       	ldd	r15, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     934:	d7 01       	movw	r26, r14
     936:	12 96       	adiw	r26, 0x02	; 2
     938:	8d 91       	ld	r24, X+
     93a:	9c 91       	ld	r25, X
     93c:	13 97       	sbiw	r26, 0x03	; 3

					if( xConstTickCount < xItemValue )
     93e:	08 17       	cp	r16, r24
     940:	19 07       	cpc	r17, r25
     942:	28 f4       	brcc	.+10     	; 0x94e <__stack+0x4f>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     944:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <xNextTaskUnblockTime+0x1>
     948:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <xNextTaskUnblockTime>
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
     94c:	2e c0       	rjmp	.+92     	; 0x9aa <__stack+0xab>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     94e:	67 01       	movw	r12, r14
     950:	b2 e0       	ldi	r27, 0x02	; 2
     952:	cb 0e       	add	r12, r27
     954:	d1 1c       	adc	r13, r1
     956:	c6 01       	movw	r24, r12
     958:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     95c:	f7 01       	movw	r30, r14
     95e:	84 89       	ldd	r24, Z+20	; 0x14
     960:	95 89       	ldd	r25, Z+21	; 0x15
     962:	89 2b       	or	r24, r25
     964:	21 f0       	breq	.+8      	; 0x96e <__stack+0x6f>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     966:	c7 01       	movw	r24, r14
     968:	0c 96       	adiw	r24, 0x0c	; 12
     96a:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     96e:	d7 01       	movw	r26, r14
     970:	56 96       	adiw	r26, 0x16	; 22
     972:	8c 91       	ld	r24, X
     974:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     978:	98 17       	cp	r25, r24
     97a:	10 f4       	brcc	.+4      	; 0x980 <__stack+0x81>
     97c:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     980:	d8 9f       	mul	r29, r24
     982:	c0 01       	movw	r24, r0
     984:	11 24       	eor	r1, r1
     986:	b6 01       	movw	r22, r12
     988:	80 58       	subi	r24, 0x80	; 128
     98a:	9e 4f       	sbci	r25, 0xFE	; 254
     98c:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     990:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     994:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     998:	d7 01       	movw	r26, r14
     99a:	56 96       	adiw	r26, 0x16	; 22
     99c:	9c 91       	ld	r25, X
     99e:	86 89       	ldd	r24, Z+22	; 0x16
     9a0:	98 17       	cp	r25, r24
     9a2:	08 f4       	brcc	.+2      	; 0x9a6 <__stack+0xa7>
     9a4:	b4 cf       	rjmp	.-152    	; 0x90e <__stack+0xf>
						{
							xSwitchRequired = pdTRUE;
     9a6:	c1 e0       	ldi	r28, 0x01	; 1
     9a8:	b2 cf       	rjmp	.-156    	; 0x90e <__stack+0xf>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     9aa:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     9ae:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     9b2:	e6 89       	ldd	r30, Z+22	; 0x16
     9b4:	b9 e0       	ldi	r27, 0x09	; 9
     9b6:	eb 9f       	mul	r30, r27
     9b8:	f0 01       	movw	r30, r0
     9ba:	11 24       	eor	r1, r1
     9bc:	e0 58       	subi	r30, 0x80	; 128
     9be:	fe 4f       	sbci	r31, 0xFE	; 254
     9c0:	80 81       	ld	r24, Z
     9c2:	82 30       	cpi	r24, 0x02	; 2
     9c4:	40 f0       	brcs	.+16     	; 0x9d6 <__stack+0xd7>
			{
				xSwitchRequired = pdTRUE;
     9c6:	c1 e0       	ldi	r28, 0x01	; 1
     9c8:	06 c0       	rjmp	.+12     	; 0x9d6 <__stack+0xd7>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     9ca:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <uxPendedTicks>
     9ce:	8f 5f       	subi	r24, 0xFF	; 255
     9d0:	80 93 48 01 	sts	0x0148, r24	; 0x800148 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     9d4:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     9d6:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <xYieldPending>
     9da:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     9dc:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     9de:	8c 2f       	mov	r24, r28
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	1f 91       	pop	r17
     9e6:	0f 91       	pop	r16
     9e8:	ff 90       	pop	r15
     9ea:	ef 90       	pop	r14
     9ec:	df 90       	pop	r13
     9ee:	cf 90       	pop	r12
     9f0:	08 95       	ret

000009f2 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     9f2:	ef 92       	push	r14
     9f4:	ff 92       	push	r15
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     9fe:	0f b6       	in	r0, 0x3f	; 63
     a00:	f8 94       	cli
     a02:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     a04:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     a08:	81 50       	subi	r24, 0x01	; 1
     a0a:	80 93 40 01 	sts	0x0140, r24	; 0x800140 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a0e:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     a12:	88 23       	and	r24, r24
     a14:	11 f0       	breq	.+4      	; 0xa1a <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	52 c0       	rjmp	.+164    	; 0xabe <xTaskResumeAll+0xcc>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     a1a:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     a1e:	88 23       	and	r24, r24
     a20:	d1 f3       	breq	.-12     	; 0xa16 <xTaskResumeAll+0x24>
     a22:	c0 e0       	ldi	r28, 0x00	; 0
     a24:	d0 e0       	ldi	r29, 0x00	; 0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
     a26:	89 e0       	ldi	r24, 0x09	; 9
     a28:	f8 2e       	mov	r15, r24

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     a2a:	ee 24       	eor	r14, r14
     a2c:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     a2e:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <xPendingReadyList>
     a32:	88 23       	and	r24, r24
     a34:	51 f1       	breq	.+84     	; 0xa8a <xTaskResumeAll+0x98>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     a36:	e0 91 66 01 	lds	r30, 0x0166	; 0x800166 <xPendingReadyList+0x5>
     a3a:	f0 91 67 01 	lds	r31, 0x0167	; 0x800167 <xPendingReadyList+0x6>
     a3e:	c6 81       	ldd	r28, Z+6	; 0x06
     a40:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a42:	ce 01       	movw	r24, r28
     a44:	0c 96       	adiw	r24, 0x0c	; 12
     a46:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     a4a:	8e 01       	movw	r16, r28
     a4c:	0e 5f       	subi	r16, 0xFE	; 254
     a4e:	1f 4f       	sbci	r17, 0xFF	; 255
     a50:	c8 01       	movw	r24, r16
     a52:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a56:	8e 89       	ldd	r24, Y+22	; 0x16
     a58:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     a5c:	98 17       	cp	r25, r24
     a5e:	10 f4       	brcc	.+4      	; 0xa64 <xTaskResumeAll+0x72>
     a60:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     a64:	f8 9e       	mul	r15, r24
     a66:	c0 01       	movw	r24, r0
     a68:	11 24       	eor	r1, r1
     a6a:	b8 01       	movw	r22, r16
     a6c:	80 58       	subi	r24, 0x80	; 128
     a6e:	9e 4f       	sbci	r25, 0xFE	; 254
     a70:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a74:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     a78:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     a7c:	9e 89       	ldd	r25, Y+22	; 0x16
     a7e:	86 89       	ldd	r24, Z+22	; 0x16
     a80:	98 17       	cp	r25, r24
     a82:	a8 f2       	brcs	.-86     	; 0xa2e <xTaskResumeAll+0x3c>
					{
						xYieldPending = pdTRUE;
     a84:	e0 92 47 01 	sts	0x0147, r14	; 0x800147 <xYieldPending>
     a88:	d2 cf       	rjmp	.-92     	; 0xa2e <xTaskResumeAll+0x3c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     a8a:	cd 2b       	or	r28, r29
     a8c:	11 f0       	breq	.+4      	; 0xa92 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     a8e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     a92:	c0 91 48 01 	lds	r28, 0x0148	; 0x800148 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     a96:	cc 23       	and	r28, r28
     a98:	51 f0       	breq	.+20     	; 0xaae <xTaskResumeAll+0xbc>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
     a9a:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     a9c:	0e 94 4d 04 	call	0x89a	; 0x89a <xTaskIncrementTick>
     aa0:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
     aa2:	d0 93 47 01 	sts	0x0147, r29	; 0x800147 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     aa6:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     aa8:	c9 f7       	brne	.-14     	; 0xa9c <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     aaa:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     aae:	80 91 47 01 	lds	r24, 0x0147	; 0x800147 <xYieldPending>
     ab2:	88 23       	and	r24, r24
     ab4:	09 f4       	brne	.+2      	; 0xab8 <xTaskResumeAll+0xc6>
     ab6:	af cf       	rjmp	.-162    	; 0xa16 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     ab8:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     abc:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     abe:	0f 90       	pop	r0
     ac0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	ef 90       	pop	r14
     ace:	08 95       	ret

00000ad0 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     ad0:	0f 93       	push	r16
     ad2:	1f 93       	push	r17
     ad4:	cf 93       	push	r28
     ad6:	df 93       	push	r29
     ad8:	8c 01       	movw	r16, r24
     ada:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     adc:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     ae0:	40 91 4b 01 	lds	r20, 0x014B	; 0x80014b <xTickCount>
     ae4:	50 91 4c 01 	lds	r21, 0x014C	; 0x80014c <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     ae8:	f8 01       	movw	r30, r16
     aea:	20 81       	ld	r18, Z
     aec:	31 81       	ldd	r19, Z+1	; 0x01
     aee:	c9 01       	movw	r24, r18
     af0:	8c 0f       	add	r24, r28
     af2:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     af4:	42 17       	cp	r20, r18
     af6:	53 07       	cpc	r21, r19
     af8:	20 f4       	brcc	.+8      	; 0xb02 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     afa:	82 17       	cp	r24, r18
     afc:	93 07       	cpc	r25, r19
     afe:	40 f4       	brcc	.+16     	; 0xb10 <vTaskDelayUntil+0x40>
     b00:	03 c0       	rjmp	.+6      	; 0xb08 <vTaskDelayUntil+0x38>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     b02:	82 17       	cp	r24, r18
     b04:	93 07       	cpc	r25, r19
     b06:	30 f0       	brcs	.+12     	; 0xb14 <vTaskDelayUntil+0x44>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     b08:	21 e0       	ldi	r18, 0x01	; 1
     b0a:	48 17       	cp	r20, r24
     b0c:	59 07       	cpc	r21, r25
     b0e:	18 f0       	brcs	.+6      	; 0xb16 <vTaskDelayUntil+0x46>
     b10:	20 e0       	ldi	r18, 0x00	; 0
     b12:	01 c0       	rjmp	.+2      	; 0xb16 <vTaskDelayUntil+0x46>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     b14:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     b16:	f8 01       	movw	r30, r16
     b18:	91 83       	std	Z+1, r25	; 0x01
     b1a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     b1c:	22 23       	and	r18, r18
     b1e:	29 f0       	breq	.+10     	; 0xb2a <vTaskDelayUntil+0x5a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     b20:	60 e0       	ldi	r22, 0x00	; 0
     b22:	84 1b       	sub	r24, r20
     b24:	95 0b       	sbc	r25, r21
     b26:	0e 94 8f 01 	call	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     b2a:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b2e:	81 11       	cpse	r24, r1
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <vTaskDelayUntil+0x66>
		{
			portYIELD_WITHIN_API();
     b32:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	08 95       	ret

00000b40 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     b40:	cf 93       	push	r28
     b42:	df 93       	push	r29
     b44:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     b46:	89 2b       	or	r24, r25
     b48:	19 f4       	brne	.+6      	; 0xb50 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     b4a:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
     b4e:	0a c0       	rjmp	.+20     	; 0xb64 <vTaskDelay+0x24>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     b50:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
     b54:	60 e0       	ldi	r22, 0x00	; 0
     b56:	ce 01       	movw	r24, r28
     b58:	0e 94 8f 01 	call	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     b5c:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b60:	88 23       	and	r24, r24
     b62:	99 f3       	breq	.-26     	; 0xb4a <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	08 95       	ret

00000b6a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     b6a:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     b6e:	88 23       	and	r24, r24
     b70:	21 f0       	breq	.+8      	; 0xb7a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     b72:	81 e0       	ldi	r24, 0x01	; 1
     b74:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     b78:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     b7a:	10 92 47 01 	sts	0x0147, r1	; 0x800147 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     b7e:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <uxTopReadyPriority>
     b82:	69 e0       	ldi	r22, 0x09	; 9
     b84:	48 2f       	mov	r20, r24
     b86:	50 e0       	ldi	r21, 0x00	; 0
     b88:	64 9f       	mul	r22, r20
     b8a:	90 01       	movw	r18, r0
     b8c:	65 9f       	mul	r22, r21
     b8e:	30 0d       	add	r19, r0
     b90:	11 24       	eor	r1, r1
     b92:	f9 01       	movw	r30, r18
     b94:	e0 58       	subi	r30, 0x80	; 128
     b96:	fe 4f       	sbci	r31, 0xFE	; 254
     b98:	90 81       	ld	r25, Z
     b9a:	91 11       	cpse	r25, r1
     b9c:	02 c0       	rjmp	.+4      	; 0xba2 <vTaskSwitchContext+0x38>
     b9e:	81 50       	subi	r24, 0x01	; 1
     ba0:	f1 cf       	rjmp	.-30     	; 0xb84 <vTaskSwitchContext+0x1a>
     ba2:	a1 81       	ldd	r26, Z+1	; 0x01
     ba4:	b2 81       	ldd	r27, Z+2	; 0x02
     ba6:	12 96       	adiw	r26, 0x02	; 2
     ba8:	0d 90       	ld	r0, X+
     baa:	bc 91       	ld	r27, X
     bac:	a0 2d       	mov	r26, r0
     bae:	b2 83       	std	Z+2, r27	; 0x02
     bb0:	a1 83       	std	Z+1, r26	; 0x01
     bb2:	2d 57       	subi	r18, 0x7D	; 125
     bb4:	3e 4f       	sbci	r19, 0xFE	; 254
     bb6:	a2 17       	cp	r26, r18
     bb8:	b3 07       	cpc	r27, r19
     bba:	31 f4       	brne	.+12     	; 0xbc8 <vTaskSwitchContext+0x5e>
     bbc:	12 96       	adiw	r26, 0x02	; 2
     bbe:	2d 91       	ld	r18, X+
     bc0:	3c 91       	ld	r19, X
     bc2:	13 97       	sbiw	r26, 0x03	; 3
     bc4:	32 83       	std	Z+2, r19	; 0x02
     bc6:	21 83       	std	Z+1, r18	; 0x01
     bc8:	99 e0       	ldi	r25, 0x09	; 9
     bca:	94 9f       	mul	r25, r20
     bcc:	f0 01       	movw	r30, r0
     bce:	95 9f       	mul	r25, r21
     bd0:	f0 0d       	add	r31, r0
     bd2:	11 24       	eor	r1, r1
     bd4:	e0 58       	subi	r30, 0x80	; 128
     bd6:	fe 4f       	sbci	r31, 0xFE	; 254
     bd8:	01 80       	ldd	r0, Z+1	; 0x01
     bda:	f2 81       	ldd	r31, Z+2	; 0x02
     bdc:	e0 2d       	mov	r30, r0
     bde:	26 81       	ldd	r18, Z+6	; 0x06
     be0:	37 81       	ldd	r19, Z+7	; 0x07
     be2:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <__data_end+0x1>
     be6:	20 93 3e 01 	sts	0x013E, r18	; 0x80013e <__data_end>
     bea:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     bee:	08 95       	ret

00000bf0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
     bf0:	0f 93       	push	r16
     bf2:	1f 93       	push	r17
     bf4:	cf 93       	push	r28
     bf6:	df 93       	push	r29
     bf8:	ec 01       	movw	r28, r24
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
     bfa:	0f b6       	in	r0, 0x3f	; 63
     bfc:	f8 94       	cli
     bfe:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
     c00:	89 2b       	or	r24, r25
     c02:	21 f4       	brne	.+8      	; 0xc0c <vTaskSuspend+0x1c>
     c04:	c0 91 3e 01 	lds	r28, 0x013E	; 0x80013e <__data_end>
     c08:	d0 91 3f 01 	lds	r29, 0x013F	; 0x80013f <__data_end+0x1>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
     c0c:	8e 01       	movw	r16, r28
     c0e:	0e 5f       	subi	r16, 0xFE	; 254
     c10:	1f 4f       	sbci	r17, 0xFF	; 255
     c12:	c8 01       	movw	r24, r16
     c14:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     c18:	8c 89       	ldd	r24, Y+20	; 0x14
     c1a:	9d 89       	ldd	r25, Y+21	; 0x15
     c1c:	89 2b       	or	r24, r25
     c1e:	21 f0       	breq	.+8      	; 0xc28 <vTaskSuspend+0x38>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c20:	ce 01       	movw	r24, r28
     c22:	0c 96       	adiw	r24, 0x0c	; 12
     c24:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
     c28:	b8 01       	movw	r22, r16
     c2a:	8e e4       	ldi	r24, 0x4E	; 78
     c2c:	91 e0       	ldi	r25, 0x01	; 1
     c2e:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
     c32:	8d a1       	ldd	r24, Y+37	; 0x25
     c34:	81 30       	cpi	r24, 0x01	; 1
     c36:	09 f4       	brne	.+2      	; 0xc3a <vTaskSuspend+0x4a>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     c38:	1d a2       	std	Y+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
     c3a:	0f 90       	pop	r0
     c3c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
     c3e:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     c42:	88 23       	and	r24, r24
     c44:	39 f0       	breq	.+14     	; 0xc54 <vTaskSuspend+0x64>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
     c46:	0f b6       	in	r0, 0x3f	; 63
     c48:	f8 94       	cli
     c4a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
     c4c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
     c50:	0f 90       	pop	r0
     c52:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
     c54:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     c58:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>
     c5c:	c8 17       	cp	r28, r24
     c5e:	d9 07       	cpc	r29, r25
     c60:	c1 f4       	brne	.+48     	; 0xc92 <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
     c62:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <xSchedulerRunning>
     c66:	88 23       	and	r24, r24
     c68:	19 f0       	breq	.+6      	; 0xc70 <vTaskSuspend+0x80>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
     c6a:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
     c6e:	11 c0       	rjmp	.+34     	; 0xc92 <vTaskSuspend+0xa2>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
     c70:	90 91 4e 01 	lds	r25, 0x014E	; 0x80014e <xSuspendedTaskList>
     c74:	80 91 4d 01 	lds	r24, 0x014D	; 0x80014d <uxCurrentNumberOfTasks>
     c78:	98 13       	cpse	r25, r24
     c7a:	05 c0       	rjmp	.+10     	; 0xc86 <vTaskSuspend+0x96>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
     c7c:	10 92 3f 01 	sts	0x013F, r1	; 0x80013f <__data_end+0x1>
     c80:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <__data_end>
     c84:	06 c0       	rjmp	.+12     	; 0xc92 <vTaskSuspend+0xa2>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
     c8e:	0c 94 b5 05 	jmp	0xb6a	; 0xb6a <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     c92:	df 91       	pop	r29
     c94:	cf 91       	pop	r28
     c96:	1f 91       	pop	r17
     c98:	0f 91       	pop	r16
     c9a:	08 95       	ret

00000c9c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     c9c:	cf 93       	push	r28
     c9e:	df 93       	push	r29
     ca0:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     ca2:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     ca6:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     caa:	64 5f       	subi	r22, 0xF4	; 244
     cac:	7f 4f       	sbci	r23, 0xFF	; 255
     cae:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cb2:	61 e0       	ldi	r22, 0x01	; 1
     cb4:	ce 01       	movw	r24, r28
}
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cba:	0c 94 8f 01 	jmp	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>

00000cbe <vTaskPlaceOnUnorderedEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
     cbe:	cf 93       	push	r28
     cc0:	df 93       	push	r29
     cc2:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     cc4:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     cc8:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     ccc:	70 68       	ori	r23, 0x80	; 128
     cce:	75 87       	std	Z+13, r23	; 0x0d
     cd0:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     cd2:	60 91 3e 01 	lds	r22, 0x013E	; 0x80013e <__data_end>
     cd6:	70 91 3f 01 	lds	r23, 0x013F	; 0x80013f <__data_end+0x1>
     cda:	64 5f       	subi	r22, 0xF4	; 244
     cdc:	7f 4f       	sbci	r23, 0xFF	; 255
     cde:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ce2:	61 e0       	ldi	r22, 0x01	; 1
     ce4:	ce 01       	movw	r24, r28
}
     ce6:	df 91       	pop	r29
     ce8:	cf 91       	pop	r28
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     cea:	0c 94 8f 01 	jmp	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>

00000cee <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     cee:	0f 93       	push	r16
     cf0:	1f 93       	push	r17
     cf2:	cf 93       	push	r28
     cf4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     cf6:	dc 01       	movw	r26, r24
     cf8:	15 96       	adiw	r26, 0x05	; 5
     cfa:	ed 91       	ld	r30, X+
     cfc:	fc 91       	ld	r31, X
     cfe:	16 97       	sbiw	r26, 0x06	; 6
     d00:	c6 81       	ldd	r28, Z+6	; 0x06
     d02:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     d04:	8e 01       	movw	r16, r28
     d06:	04 5f       	subi	r16, 0xF4	; 244
     d08:	1f 4f       	sbci	r17, 0xFF	; 255
     d0a:	c8 01       	movw	r24, r16
     d0c:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     d10:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
     d14:	81 11       	cpse	r24, r1
     d16:	14 c0       	rjmp	.+40     	; 0xd40 <xTaskRemoveFromEventList+0x52>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     d18:	0a 50       	subi	r16, 0x0A	; 10
     d1a:	11 09       	sbc	r17, r1
     d1c:	c8 01       	movw	r24, r16
     d1e:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     d22:	8e 89       	ldd	r24, Y+22	; 0x16
     d24:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     d28:	98 17       	cp	r25, r24
     d2a:	10 f4       	brcc	.+4      	; 0xd30 <xTaskRemoveFromEventList+0x42>
     d2c:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     d30:	b9 e0       	ldi	r27, 0x09	; 9
     d32:	8b 9f       	mul	r24, r27
     d34:	c0 01       	movw	r24, r0
     d36:	11 24       	eor	r1, r1
     d38:	b8 01       	movw	r22, r16
     d3a:	80 58       	subi	r24, 0x80	; 128
     d3c:	9e 4f       	sbci	r25, 0xFE	; 254
     d3e:	03 c0       	rjmp	.+6      	; 0xd46 <xTaskRemoveFromEventList+0x58>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     d40:	b8 01       	movw	r22, r16
     d42:	81 e6       	ldi	r24, 0x61	; 97
     d44:	91 e0       	ldi	r25, 0x01	; 1
     d46:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d4a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     d4e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     d52:	9e 89       	ldd	r25, Y+22	; 0x16
     d54:	86 89       	ldd	r24, Z+22	; 0x16
     d56:	89 17       	cp	r24, r25
     d58:	20 f4       	brcc	.+8      	; 0xd62 <xTaskRemoveFromEventList+0x74>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     d5a:	81 e0       	ldi	r24, 0x01	; 1
     d5c:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     d60:	01 c0       	rjmp	.+2      	; 0xd64 <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		xReturn = pdFALSE;
     d62:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     d64:	df 91       	pop	r29
     d66:	cf 91       	pop	r28
     d68:	1f 91       	pop	r17
     d6a:	0f 91       	pop	r16
     d6c:	08 95       	ret

00000d6e <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
     d6e:	0f 93       	push	r16
     d70:	1f 93       	push	r17
     d72:	cf 93       	push	r28
     d74:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d76:	70 68       	ori	r23, 0x80	; 128
     d78:	fc 01       	movw	r30, r24
     d7a:	71 83       	std	Z+1, r23	; 0x01
     d7c:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
     d7e:	c6 81       	ldd	r28, Z+6	; 0x06
     d80:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
     d82:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
     d86:	8e 01       	movw	r16, r28
     d88:	0e 5f       	subi	r16, 0xFE	; 254
     d8a:	1f 4f       	sbci	r17, 0xFF	; 255
     d8c:	c8 01       	movw	r24, r16
     d8e:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
     d92:	8e 89       	ldd	r24, Y+22	; 0x16
     d94:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
     d98:	98 17       	cp	r25, r24
     d9a:	10 f4       	brcc	.+4      	; 0xda0 <vTaskRemoveFromUnorderedEventList+0x32>
     d9c:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
     da0:	f9 e0       	ldi	r31, 0x09	; 9
     da2:	8f 9f       	mul	r24, r31
     da4:	c0 01       	movw	r24, r0
     da6:	11 24       	eor	r1, r1
     da8:	b8 01       	movw	r22, r16
     daa:	80 58       	subi	r24, 0x80	; 128
     dac:	9e 4f       	sbci	r25, 0xFE	; 254
     dae:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     db2:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     db6:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     dba:	9e 89       	ldd	r25, Y+22	; 0x16
     dbc:	86 89       	ldd	r24, Z+22	; 0x16
     dbe:	89 17       	cp	r24, r25
     dc0:	18 f4       	brcc	.+6      	; 0xdc8 <vTaskRemoveFromUnorderedEventList+0x5a>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
	}
}
     dc8:	df 91       	pop	r29
     dca:	cf 91       	pop	r28
     dcc:	1f 91       	pop	r17
     dce:	0f 91       	pop	r16
     dd0:	08 95       	ret

00000dd2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	f8 94       	cli
     dd6:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
     dd8:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <xNumOfOverflows>
     ddc:	fc 01       	movw	r30, r24
     dde:	20 83       	st	Z, r18
		pxTimeOut->xTimeOnEntering = xTickCount;
     de0:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <xTickCount>
     de4:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <xTickCount+0x1>
     de8:	32 83       	std	Z+2, r19	; 0x02
     dea:	21 83       	std	Z+1, r18	; 0x01
	}
	taskEXIT_CRITICAL();
     dec:	0f 90       	pop	r0
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	08 95       	ret

00000df2 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     df2:	20 91 46 01 	lds	r18, 0x0146	; 0x800146 <xNumOfOverflows>
     df6:	fc 01       	movw	r30, r24
     df8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
     dfa:	20 91 4b 01 	lds	r18, 0x014B	; 0x80014b <xTickCount>
     dfe:	30 91 4c 01 	lds	r19, 0x014C	; 0x80014c <xTickCount+0x1>
     e02:	32 83       	std	Z+2, r19	; 0x02
     e04:	21 83       	std	Z+1, r18	; 0x01
     e06:	08 95       	ret

00000e08 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
     e08:	cf 93       	push	r28
     e0a:	df 93       	push	r29
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     e0c:	0f b6       	in	r0, 0x3f	; 63
     e0e:	f8 94       	cli
     e10:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
     e12:	40 91 4b 01 	lds	r20, 0x014B	; 0x80014b <xTickCount>
     e16:	50 91 4c 01 	lds	r21, 0x014C	; 0x80014c <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
     e1a:	db 01       	movw	r26, r22
     e1c:	2d 91       	ld	r18, X+
     e1e:	3c 91       	ld	r19, X
     e20:	2f 3f       	cpi	r18, 0xFF	; 255
     e22:	bf ef       	ldi	r27, 0xFF	; 255
     e24:	3b 07       	cpc	r19, r27
     e26:	d9 f0       	breq	.+54     	; 0xe5e <xTaskCheckForTimeOut+0x56>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     e28:	ec 01       	movw	r28, r24
     e2a:	e9 81       	ldd	r30, Y+1	; 0x01
     e2c:	fa 81       	ldd	r31, Y+2	; 0x02
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
     e2e:	a0 91 46 01 	lds	r26, 0x0146	; 0x800146 <xNumOfOverflows>
     e32:	b8 81       	ld	r27, Y
     e34:	ba 17       	cp	r27, r26
     e36:	19 f0       	breq	.+6      	; 0xe3e <xTaskCheckForTimeOut+0x36>
     e38:	4e 17       	cp	r20, r30
     e3a:	5f 07       	cpc	r21, r31
     e3c:	90 f4       	brcc	.+36     	; 0xe62 <xTaskCheckForTimeOut+0x5a>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     e3e:	4e 1b       	sub	r20, r30
     e40:	5f 0b       	sbc	r21, r31
     e42:	fb 01       	movw	r30, r22
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
     e44:	42 17       	cp	r20, r18
     e46:	53 07       	cpc	r21, r19
     e48:	38 f4       	brcc	.+14     	; 0xe58 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
     e4a:	24 1b       	sub	r18, r20
     e4c:	35 0b       	sbc	r19, r21
     e4e:	31 83       	std	Z+1, r19	; 0x01
     e50:	20 83       	st	Z, r18
			vTaskInternalSetTimeOutState( pxTimeOut );
     e52:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskInternalSetTimeOutState>
     e56:	03 c0       	rjmp	.+6      	; 0xe5e <xTaskCheckForTimeOut+0x56>
			xReturn = pdFALSE;
		}
		else
		{
			*pxTicksToWait = 0;
     e58:	11 82       	std	Z+1, r1	; 0x01
     e5a:	10 82       	st	Z, r1
     e5c:	02 c0       	rjmp	.+4      	; 0xe62 <xTaskCheckForTimeOut+0x5a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
     e5e:	80 e0       	ldi	r24, 0x00	; 0
     e60:	01 c0       	rjmp	.+2      	; 0xe64 <xTaskCheckForTimeOut+0x5c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
     e62:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     e64:	0f 90       	pop	r0
     e66:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	08 95       	ret

00000e6e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
     e6e:	81 e0       	ldi	r24, 0x01	; 1
     e70:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
     e74:	08 95       	ret

00000e76 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
     e76:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
     e7a:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>

		return xReturn;
	}
     e7e:	08 95       	ret

00000e80 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
     e80:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e84:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     e88:	84 85       	ldd	r24, Z+12	; 0x0c
     e8a:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e8c:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     e90:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     e94:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
     e98:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
     e9c:	56 96       	adiw	r26, 0x16	; 22
     e9e:	4c 91       	ld	r20, X
     ea0:	24 e0       	ldi	r18, 0x04	; 4
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	24 1b       	sub	r18, r20
     ea6:	31 09       	sbc	r19, r1
     ea8:	35 87       	std	Z+13, r19	; 0x0d
     eaa:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
     eac:	08 95       	ret

00000eae <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
     eae:	0f 93       	push	r16
     eb0:	1f 93       	push	r17
     eb2:	18 2f       	mov	r17, r24
     eb4:	cb 01       	movw	r24, r22
	uint32_t ulReturn;

		taskENTER_CRITICAL();
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	f8 94       	cli
     eba:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
     ebc:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     ec0:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     ec4:	41 a1       	ldd	r20, Z+33	; 0x21
     ec6:	52 a1       	ldd	r21, Z+34	; 0x22
     ec8:	63 a1       	ldd	r22, Z+35	; 0x23
     eca:	74 a1       	ldd	r23, Z+36	; 0x24
     ecc:	45 2b       	or	r20, r21
     ece:	46 2b       	or	r20, r22
     ed0:	47 2b       	or	r20, r23
     ed2:	69 f4       	brne	.+26     	; 0xeee <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     ed4:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     ed8:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     edc:	21 e0       	ldi	r18, 0x01	; 1
     ede:	25 a3       	std	Z+37, r18	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     ee0:	00 97       	sbiw	r24, 0x00	; 0
     ee2:	29 f0       	breq	.+10     	; 0xeee <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     ee4:	61 e0       	ldi	r22, 0x01	; 1
     ee6:	0e 94 8f 01 	call	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     eea:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     eee:	0f 90       	pop	r0
     ef0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
     ef8:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     efc:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f00:	61 a1       	ldd	r22, Z+33	; 0x21
     f02:	72 a1       	ldd	r23, Z+34	; 0x22
     f04:	83 a1       	ldd	r24, Z+35	; 0x23
     f06:	94 a1       	ldd	r25, Z+36	; 0x24

			if( ulReturn != 0UL )
     f08:	61 15       	cp	r22, r1
     f0a:	71 05       	cpc	r23, r1
     f0c:	81 05       	cpc	r24, r1
     f0e:	91 05       	cpc	r25, r1
     f10:	a9 f0       	breq	.+42     	; 0xf3c <ulTaskNotifyTake+0x8e>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     f12:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f16:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
     f1a:	11 23       	and	r17, r17
     f1c:	29 f0       	breq	.+10     	; 0xf28 <ulTaskNotifyTake+0x7a>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
     f1e:	11 a2       	std	Z+33, r1	; 0x21
     f20:	12 a2       	std	Z+34, r1	; 0x22
     f22:	13 a2       	std	Z+35, r1	; 0x23
     f24:	14 a2       	std	Z+36, r1	; 0x24
     f26:	0a c0       	rjmp	.+20     	; 0xf3c <ulTaskNotifyTake+0x8e>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
     f28:	8b 01       	movw	r16, r22
     f2a:	9c 01       	movw	r18, r24
     f2c:	01 50       	subi	r16, 0x01	; 1
     f2e:	11 09       	sbc	r17, r1
     f30:	21 09       	sbc	r18, r1
     f32:	31 09       	sbc	r19, r1
     f34:	01 a3       	std	Z+33, r16	; 0x21
     f36:	12 a3       	std	Z+34, r17	; 0x22
     f38:	23 a3       	std	Z+35, r18	; 0x23
     f3a:	34 a3       	std	Z+36, r19	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
     f3c:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f40:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f44:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
     f46:	0f 90       	pop	r0
     f48:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
     f4a:	1f 91       	pop	r17
     f4c:	0f 91       	pop	r16
     f4e:	08 95       	ret

00000f50 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
     f50:	4f 92       	push	r4
     f52:	5f 92       	push	r5
     f54:	6f 92       	push	r6
     f56:	7f 92       	push	r7
     f58:	8f 92       	push	r8
     f5a:	9f 92       	push	r9
     f5c:	af 92       	push	r10
     f5e:	bf 92       	push	r11
     f60:	ef 92       	push	r14
     f62:	ff 92       	push	r15
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	49 01       	movw	r8, r18
     f6a:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
     f6c:	0f b6       	in	r0, 0x3f	; 63
     f6e:	f8 94       	cli
     f70:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     f72:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f76:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f7a:	25 a1       	ldd	r18, Z+37	; 0x25
     f7c:	22 30       	cpi	r18, 0x02	; 2
     f7e:	39 f1       	breq	.+78     	; 0xfce <xTaskNotifyWait+0x7e>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
     f80:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     f84:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     f88:	21 a1       	ldd	r18, Z+33	; 0x21
     f8a:	32 a1       	ldd	r19, Z+34	; 0x22
     f8c:	43 a1       	ldd	r20, Z+35	; 0x23
     f8e:	54 a1       	ldd	r21, Z+36	; 0x24
     f90:	2b 01       	movw	r4, r22
     f92:	3c 01       	movw	r6, r24
     f94:	40 94       	com	r4
     f96:	50 94       	com	r5
     f98:	60 94       	com	r6
     f9a:	70 94       	com	r7
     f9c:	d3 01       	movw	r26, r6
     f9e:	c2 01       	movw	r24, r4
     fa0:	82 23       	and	r24, r18
     fa2:	93 23       	and	r25, r19
     fa4:	a4 23       	and	r26, r20
     fa6:	b5 23       	and	r27, r21
     fa8:	81 a3       	std	Z+33, r24	; 0x21
     faa:	92 a3       	std	Z+34, r25	; 0x22
     fac:	a3 a3       	std	Z+35, r26	; 0x23
     fae:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
     fb0:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     fb4:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
     fbc:	e1 14       	cp	r14, r1
     fbe:	f1 04       	cpc	r15, r1
     fc0:	31 f0       	breq	.+12     	; 0xfce <xTaskNotifyWait+0x7e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     fc2:	61 e0       	ldi	r22, 0x01	; 1
     fc4:	c7 01       	movw	r24, r14
     fc6:	0e 94 8f 01 	call	0x31e	; 0x31e <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
     fca:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
     fce:	0f 90       	pop	r0
     fd0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
     fd2:	0f b6       	in	r0, 0x3f	; 63
     fd4:	f8 94       	cli
     fd6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
     fd8:	01 15       	cp	r16, r1
     fda:	11 05       	cpc	r17, r1
     fdc:	69 f0       	breq	.+26     	; 0xff8 <xTaskNotifyWait+0xa8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
     fde:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     fe2:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
     fe6:	81 a1       	ldd	r24, Z+33	; 0x21
     fe8:	92 a1       	ldd	r25, Z+34	; 0x22
     fea:	a3 a1       	ldd	r26, Z+35	; 0x23
     fec:	b4 a1       	ldd	r27, Z+36	; 0x24
     fee:	f8 01       	movw	r30, r16
     ff0:	80 83       	st	Z, r24
     ff2:	91 83       	std	Z+1, r25	; 0x01
     ff4:	a2 83       	std	Z+2, r26	; 0x02
     ff6:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
     ff8:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
     ffc:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    1000:	85 a1       	ldd	r24, Z+37	; 0x25
    1002:	82 30       	cpi	r24, 0x02	; 2
    1004:	c1 f4       	brne	.+48     	; 0x1036 <xTaskNotifyWait+0xe6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    1006:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    100a:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    100e:	41 a1       	ldd	r20, Z+33	; 0x21
    1010:	52 a1       	ldd	r21, Z+34	; 0x22
    1012:	63 a1       	ldd	r22, Z+35	; 0x23
    1014:	74 a1       	ldd	r23, Z+36	; 0x24
    1016:	d5 01       	movw	r26, r10
    1018:	c4 01       	movw	r24, r8
    101a:	80 95       	com	r24
    101c:	90 95       	com	r25
    101e:	a0 95       	com	r26
    1020:	b0 95       	com	r27
    1022:	84 23       	and	r24, r20
    1024:	95 23       	and	r25, r21
    1026:	a6 23       	and	r26, r22
    1028:	b7 23       	and	r27, r23
    102a:	81 a3       	std	Z+33, r24	; 0x21
    102c:	92 a3       	std	Z+34, r25	; 0x22
    102e:	a3 a3       	std	Z+35, r26	; 0x23
    1030:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    1032:	81 e0       	ldi	r24, 0x01	; 1
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <xTaskNotifyWait+0xe8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    1036:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    1038:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    103c:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    1040:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    1042:	0f 90       	pop	r0
    1044:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1046:	1f 91       	pop	r17
    1048:	0f 91       	pop	r16
    104a:	ff 90       	pop	r15
    104c:	ef 90       	pop	r14
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	9f 90       	pop	r9
    1054:	8f 90       	pop	r8
    1056:	7f 90       	pop	r7
    1058:	6f 90       	pop	r6
    105a:	5f 90       	pop	r5
    105c:	4f 90       	pop	r4
    105e:	08 95       	ret

00001060 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    1060:	0f 93       	push	r16
    1062:	1f 93       	push	r17
    1064:	cf 93       	push	r28
    1066:	df 93       	push	r29
    1068:	fc 01       	movw	r30, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;

		taskENTER_CRITICAL();
    106a:	0f b6       	in	r0, 0x3f	; 63
    106c:	f8 94       	cli
    106e:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    1070:	01 15       	cp	r16, r1
    1072:	11 05       	cpc	r17, r1
    1074:	49 f0       	breq	.+18     	; 0x1088 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1076:	81 a1       	ldd	r24, Z+33	; 0x21
    1078:	92 a1       	ldd	r25, Z+34	; 0x22
    107a:	a3 a1       	ldd	r26, Z+35	; 0x23
    107c:	b4 a1       	ldd	r27, Z+36	; 0x24
    107e:	e8 01       	movw	r28, r16
    1080:	88 83       	st	Y, r24
    1082:	99 83       	std	Y+1, r25	; 0x01
    1084:	aa 83       	std	Y+2, r26	; 0x02
    1086:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1088:	35 a1       	ldd	r19, Z+37	; 0x25

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    108a:	82 e0       	ldi	r24, 0x02	; 2
    108c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    108e:	22 30       	cpi	r18, 0x02	; 2
    1090:	89 f0       	breq	.+34     	; 0x10b4 <xTaskGenericNotify+0x54>
    1092:	58 f4       	brcc	.+22     	; 0x10aa <xTaskGenericNotify+0x4a>
    1094:	21 30       	cpi	r18, 0x01	; 1
    1096:	01 f5       	brne	.+64     	; 0x10d8 <xTaskGenericNotify+0x78>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1098:	81 a1       	ldd	r24, Z+33	; 0x21
    109a:	92 a1       	ldd	r25, Z+34	; 0x22
    109c:	a3 a1       	ldd	r26, Z+35	; 0x23
    109e:	b4 a1       	ldd	r27, Z+36	; 0x24
    10a0:	48 2b       	or	r20, r24
    10a2:	59 2b       	or	r21, r25
    10a4:	6a 2b       	or	r22, r26
    10a6:	7b 2b       	or	r23, r27
    10a8:	13 c0       	rjmp	.+38     	; 0x10d0 <xTaskGenericNotify+0x70>

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    10aa:	23 30       	cpi	r18, 0x03	; 3
    10ac:	89 f0       	breq	.+34     	; 0x10d0 <xTaskGenericNotify+0x70>
    10ae:	24 30       	cpi	r18, 0x04	; 4
    10b0:	69 f0       	breq	.+26     	; 0x10cc <xTaskGenericNotify+0x6c>
    10b2:	12 c0       	rjmp	.+36     	; 0x10d8 <xTaskGenericNotify+0x78>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    10b4:	81 a1       	ldd	r24, Z+33	; 0x21
    10b6:	92 a1       	ldd	r25, Z+34	; 0x22
    10b8:	a3 a1       	ldd	r26, Z+35	; 0x23
    10ba:	b4 a1       	ldd	r27, Z+36	; 0x24
    10bc:	01 96       	adiw	r24, 0x01	; 1
    10be:	a1 1d       	adc	r26, r1
    10c0:	b1 1d       	adc	r27, r1
    10c2:	81 a3       	std	Z+33, r24	; 0x21
    10c4:	92 a3       	std	Z+34, r25	; 0x22
    10c6:	a3 a3       	std	Z+35, r26	; 0x23
    10c8:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    10ca:	06 c0       	rjmp	.+12     	; 0x10d8 <xTaskGenericNotify+0x78>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    10cc:	32 30       	cpi	r19, 0x02	; 2
    10ce:	49 f1       	breq	.+82     	; 0x1122 <xTaskGenericNotify+0xc2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    10d0:	41 a3       	std	Z+33, r20	; 0x21
    10d2:	52 a3       	std	Z+34, r21	; 0x22
    10d4:	63 a3       	std	Z+35, r22	; 0x23
    10d6:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    10d8:	31 30       	cpi	r19, 0x01	; 1
    10da:	09 f5       	brne	.+66     	; 0x111e <xTaskGenericNotify+0xbe>
    10dc:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    10de:	8f 01       	movw	r16, r30
    10e0:	0e 5f       	subi	r16, 0xFE	; 254
    10e2:	1f 4f       	sbci	r17, 0xFF	; 255
    10e4:	c8 01       	movw	r24, r16
    10e6:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    10ea:	8e 89       	ldd	r24, Y+22	; 0x16
    10ec:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
    10f0:	98 17       	cp	r25, r24
    10f2:	10 f4       	brcc	.+4      	; 0x10f8 <xTaskGenericNotify+0x98>
    10f4:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
    10f8:	29 e0       	ldi	r18, 0x09	; 9
    10fa:	82 9f       	mul	r24, r18
    10fc:	c0 01       	movw	r24, r0
    10fe:	11 24       	eor	r1, r1
    1100:	b8 01       	movw	r22, r16
    1102:	80 58       	subi	r24, 0x80	; 128
    1104:	9e 4f       	sbci	r25, 0xFE	; 254
    1106:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    110a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    110e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    1112:	9e 89       	ldd	r25, Y+22	; 0x16
    1114:	86 89       	ldd	r24, Z+22	; 0x16
    1116:	89 17       	cp	r24, r25
    1118:	10 f4       	brcc	.+4      	; 0x111e <xTaskGenericNotify+0xbe>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    111a:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    111e:	81 e0       	ldi	r24, 0x01	; 1
    1120:	01 c0       	rjmp	.+2      	; 0x1124 <xTaskGenericNotify+0xc4>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1122:	80 e0       	ldi	r24, 0x00	; 0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    1124:	0f 90       	pop	r0
    1126:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	1f 91       	pop	r17
    112e:	0f 91       	pop	r16
    1130:	08 95       	ret

00001132 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1132:	ef 92       	push	r14
    1134:	ff 92       	push	r15
    1136:	0f 93       	push	r16
    1138:	1f 93       	push	r17
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    1140:	01 15       	cp	r16, r1
    1142:	11 05       	cpc	r17, r1
    1144:	49 f0       	breq	.+18     	; 0x1158 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    1146:	81 a1       	ldd	r24, Z+33	; 0x21
    1148:	92 a1       	ldd	r25, Z+34	; 0x22
    114a:	a3 a1       	ldd	r26, Z+35	; 0x23
    114c:	b4 a1       	ldd	r27, Z+36	; 0x24
    114e:	e8 01       	movw	r28, r16
    1150:	88 83       	st	Y, r24
    1152:	99 83       	std	Y+1, r25	; 0x01
    1154:	aa 83       	std	Y+2, r26	; 0x02
    1156:	bb 83       	std	Y+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1158:	35 a1       	ldd	r19, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    115a:	82 e0       	ldi	r24, 0x02	; 2
    115c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    115e:	22 30       	cpi	r18, 0x02	; 2
    1160:	89 f0       	breq	.+34     	; 0x1184 <xTaskGenericNotifyFromISR+0x52>
    1162:	58 f4       	brcc	.+22     	; 0x117a <xTaskGenericNotifyFromISR+0x48>
    1164:	21 30       	cpi	r18, 0x01	; 1
    1166:	01 f5       	brne	.+64     	; 0x11a8 <xTaskGenericNotifyFromISR+0x76>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    1168:	81 a1       	ldd	r24, Z+33	; 0x21
    116a:	92 a1       	ldd	r25, Z+34	; 0x22
    116c:	a3 a1       	ldd	r26, Z+35	; 0x23
    116e:	b4 a1       	ldd	r27, Z+36	; 0x24
    1170:	48 2b       	or	r20, r24
    1172:	59 2b       	or	r21, r25
    1174:	6a 2b       	or	r22, r26
    1176:	7b 2b       	or	r23, r27
    1178:	13 c0       	rjmp	.+38     	; 0x11a0 <xTaskGenericNotifyFromISR+0x6e>
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
    117a:	23 30       	cpi	r18, 0x03	; 3
    117c:	89 f0       	breq	.+34     	; 0x11a0 <xTaskGenericNotifyFromISR+0x6e>
    117e:	24 30       	cpi	r18, 0x04	; 4
    1180:	69 f0       	breq	.+26     	; 0x119c <xTaskGenericNotifyFromISR+0x6a>
    1182:	12 c0       	rjmp	.+36     	; 0x11a8 <xTaskGenericNotifyFromISR+0x76>
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    1184:	81 a1       	ldd	r24, Z+33	; 0x21
    1186:	92 a1       	ldd	r25, Z+34	; 0x22
    1188:	a3 a1       	ldd	r26, Z+35	; 0x23
    118a:	b4 a1       	ldd	r27, Z+36	; 0x24
    118c:	01 96       	adiw	r24, 0x01	; 1
    118e:	a1 1d       	adc	r26, r1
    1190:	b1 1d       	adc	r27, r1
    1192:	81 a3       	std	Z+33, r24	; 0x21
    1194:	92 a3       	std	Z+34, r25	; 0x22
    1196:	a3 a3       	std	Z+35, r26	; 0x23
    1198:	b4 a3       	std	Z+36, r27	; 0x24
					break;
    119a:	06 c0       	rjmp	.+12     	; 0x11a8 <xTaskGenericNotifyFromISR+0x76>
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    119c:	32 30       	cpi	r19, 0x02	; 2
    119e:	d9 f1       	breq	.+118    	; 0x1216 <xTaskGenericNotifyFromISR+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    11a0:	41 a3       	std	Z+33, r20	; 0x21
    11a2:	52 a3       	std	Z+34, r21	; 0x22
    11a4:	63 a3       	std	Z+35, r22	; 0x23
    11a6:	74 a3       	std	Z+36, r23	; 0x24

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    11a8:	31 30       	cpi	r19, 0x01	; 1
    11aa:	11 f0       	breq	.+4      	; 0x11b0 <xTaskGenericNotifyFromISR+0x7e>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    11ac:	81 e0       	ldi	r24, 0x01	; 1
    11ae:	34 c0       	rjmp	.+104    	; 0x1218 <xTaskGenericNotifyFromISR+0xe6>
    11b0:	ef 01       	movw	r28, r30
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11b2:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
    11b6:	81 11       	cpse	r24, r1
    11b8:	15 c0       	rjmp	.+42     	; 0x11e4 <xTaskGenericNotifyFromISR+0xb2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    11ba:	8f 01       	movw	r16, r30
    11bc:	0e 5f       	subi	r16, 0xFE	; 254
    11be:	1f 4f       	sbci	r17, 0xFF	; 255
    11c0:	c8 01       	movw	r24, r16
    11c2:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    11c6:	8e 89       	ldd	r24, Y+22	; 0x16
    11c8:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
    11cc:	98 17       	cp	r25, r24
    11ce:	10 f4       	brcc	.+4      	; 0x11d4 <xTaskGenericNotifyFromISR+0xa2>
    11d0:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
    11d4:	e9 e0       	ldi	r30, 0x09	; 9
    11d6:	8e 9f       	mul	r24, r30
    11d8:	c0 01       	movw	r24, r0
    11da:	11 24       	eor	r1, r1
    11dc:	b8 01       	movw	r22, r16
    11de:	80 58       	subi	r24, 0x80	; 128
    11e0:	9e 4f       	sbci	r25, 0xFE	; 254
    11e2:	05 c0       	rjmp	.+10     	; 0x11ee <xTaskGenericNotifyFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    11e4:	bf 01       	movw	r22, r30
    11e6:	64 5f       	subi	r22, 0xF4	; 244
    11e8:	7f 4f       	sbci	r23, 0xFF	; 255
    11ea:	81 e6       	ldi	r24, 0x61	; 97
    11ec:	91 e0       	ldi	r25, 0x01	; 1
    11ee:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    11f2:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    11f6:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    11fa:	9e 89       	ldd	r25, Y+22	; 0x16
    11fc:	86 89       	ldd	r24, Z+22	; 0x16
    11fe:	89 17       	cp	r24, r25
    1200:	a8 f6       	brcc	.-86     	; 0x11ac <xTaskGenericNotifyFromISR+0x7a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    1202:	e1 14       	cp	r14, r1
    1204:	f1 04       	cpc	r15, r1
    1206:	19 f0       	breq	.+6      	; 0x120e <xTaskGenericNotifyFromISR+0xdc>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	e7 01       	movw	r28, r14
    120c:	88 83       	st	Y, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <xTaskGenericNotifyFromISR+0xe6>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    1216:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    1218:	df 91       	pop	r29
    121a:	cf 91       	pop	r28
    121c:	1f 91       	pop	r17
    121e:	0f 91       	pop	r16
    1220:	ff 90       	pop	r15
    1222:	ef 90       	pop	r14
    1224:	08 95       	ret

00001226 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    1226:	ef 92       	push	r14
    1228:	ff 92       	push	r15
    122a:	0f 93       	push	r16
    122c:	1f 93       	push	r17
    122e:	cf 93       	push	r28
    1230:	df 93       	push	r29
    1232:	fc 01       	movw	r30, r24

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    1234:	25 a1       	ldd	r18, Z+37	; 0x25
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    1236:	82 e0       	ldi	r24, 0x02	; 2
    1238:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    123a:	81 a1       	ldd	r24, Z+33	; 0x21
    123c:	92 a1       	ldd	r25, Z+34	; 0x22
    123e:	a3 a1       	ldd	r26, Z+35	; 0x23
    1240:	b4 a1       	ldd	r27, Z+36	; 0x24
    1242:	01 96       	adiw	r24, 0x01	; 1
    1244:	a1 1d       	adc	r26, r1
    1246:	b1 1d       	adc	r27, r1
    1248:	81 a3       	std	Z+33, r24	; 0x21
    124a:	92 a3       	std	Z+34, r25	; 0x22
    124c:	a3 a3       	std	Z+35, r26	; 0x23
    124e:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    1250:	21 30       	cpi	r18, 0x01	; 1
    1252:	a1 f5       	brne	.+104    	; 0x12bc <vTaskNotifyGiveFromISR+0x96>
    1254:	8b 01       	movw	r16, r22
    1256:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1258:	80 91 40 01 	lds	r24, 0x0140	; 0x800140 <uxSchedulerSuspended>
    125c:	81 11       	cpse	r24, r1
    125e:	16 c0       	rjmp	.+44     	; 0x128c <vTaskNotifyGiveFromISR+0x66>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1260:	7f 01       	movw	r14, r30
    1262:	22 e0       	ldi	r18, 0x02	; 2
    1264:	e2 0e       	add	r14, r18
    1266:	f1 1c       	adc	r15, r1
    1268:	c7 01       	movw	r24, r14
    126a:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    126e:	8e 89       	ldd	r24, Y+22	; 0x16
    1270:	90 91 4a 01 	lds	r25, 0x014A	; 0x80014a <uxTopReadyPriority>
    1274:	98 17       	cp	r25, r24
    1276:	10 f4       	brcc	.+4      	; 0x127c <vTaskNotifyGiveFromISR+0x56>
    1278:	80 93 4a 01 	sts	0x014A, r24	; 0x80014a <uxTopReadyPriority>
    127c:	e9 e0       	ldi	r30, 0x09	; 9
    127e:	8e 9f       	mul	r24, r30
    1280:	c0 01       	movw	r24, r0
    1282:	11 24       	eor	r1, r1
    1284:	b7 01       	movw	r22, r14
    1286:	80 58       	subi	r24, 0x80	; 128
    1288:	9e 4f       	sbci	r25, 0xFE	; 254
    128a:	05 c0       	rjmp	.+10     	; 0x1296 <vTaskNotifyGiveFromISR+0x70>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    128c:	bf 01       	movw	r22, r30
    128e:	64 5f       	subi	r22, 0xF4	; 244
    1290:	7f 4f       	sbci	r23, 0xFF	; 255
    1292:	81 e6       	ldi	r24, 0x61	; 97
    1294:	91 e0       	ldi	r25, 0x01	; 1
    1296:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    129a:	e0 91 3e 01 	lds	r30, 0x013E	; 0x80013e <__data_end>
    129e:	f0 91 3f 01 	lds	r31, 0x013F	; 0x80013f <__data_end+0x1>
    12a2:	9e 89       	ldd	r25, Y+22	; 0x16
    12a4:	86 89       	ldd	r24, Z+22	; 0x16
    12a6:	89 17       	cp	r24, r25
    12a8:	48 f4       	brcc	.+18     	; 0x12bc <vTaskNotifyGiveFromISR+0x96>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    12aa:	01 15       	cp	r16, r1
    12ac:	11 05       	cpc	r17, r1
    12ae:	19 f0       	breq	.+6      	; 0x12b6 <vTaskNotifyGiveFromISR+0x90>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	f8 01       	movw	r30, r16
    12b4:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    12b6:	81 e0       	ldi	r24, 0x01	; 1
    12b8:	80 93 47 01 	sts	0x0147, r24	; 0x800147 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    12bc:	df 91       	pop	r29
    12be:	cf 91       	pop	r28
    12c0:	1f 91       	pop	r17
    12c2:	0f 91       	pop	r16
    12c4:	ff 90       	pop	r15
    12c6:	ef 90       	pop	r14
    12c8:	08 95       	ret

000012ca <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    12ca:	00 97       	sbiw	r24, 0x00	; 0
    12cc:	21 f4       	brne	.+8      	; 0x12d6 <xTaskNotifyStateClear+0xc>
    12ce:	80 91 3e 01 	lds	r24, 0x013E	; 0x80013e <__data_end>
    12d2:	90 91 3f 01 	lds	r25, 0x013F	; 0x80013f <__data_end+0x1>

		taskENTER_CRITICAL();
    12d6:	0f b6       	in	r0, 0x3f	; 63
    12d8:	f8 94       	cli
    12da:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    12dc:	fc 01       	movw	r30, r24
    12de:	25 a1       	ldd	r18, Z+37	; 0x25
    12e0:	22 30       	cpi	r18, 0x02	; 2
    12e2:	19 f4       	brne	.+6      	; 0x12ea <xTaskNotifyStateClear+0x20>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    12e4:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	01 c0       	rjmp	.+2      	; 0x12ec <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    12ea:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    12ec:	0f 90       	pop	r0
    12ee:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    12f0:	08 95       	ret

000012f2 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    12f2:	0f b6       	in	r0, 0x3f	; 63
    12f4:	f8 94       	cli
    12f6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    12f8:	fc 01       	movw	r30, r24
    12fa:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    12fc:	0f 90       	pop	r0
    12fe:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	91 11       	cpse	r25, r1
    1304:	80 e0       	ldi	r24, 0x00	; 0
}
    1306:	08 95       	ret

00001308 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	ec 01       	movw	r28, r24
    1312:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1314:	1a 8d       	ldd	r17, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1316:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1318:	44 23       	and	r20, r20
    131a:	b1 f1       	breq	.+108    	; 0x1388 <prvCopyDataToQueue+0x80>
    131c:	50 e0       	ldi	r21, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    131e:	01 11       	cpse	r16, r1
    1320:	15 c0       	rjmp	.+42     	; 0x134c <prvCopyDataToQueue+0x44>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1322:	8a 81       	ldd	r24, Y+2	; 0x02
    1324:	9b 81       	ldd	r25, Y+3	; 0x03
    1326:	0e 94 94 12 	call	0x2528	; 0x2528 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    132a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    132c:	8a 81       	ldd	r24, Y+2	; 0x02
    132e:	9b 81       	ldd	r25, Y+3	; 0x03
    1330:	82 0f       	add	r24, r18
    1332:	91 1d       	adc	r25, r1
    1334:	9b 83       	std	Y+3, r25	; 0x03
    1336:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1338:	2c 81       	ldd	r18, Y+4	; 0x04
    133a:	3d 81       	ldd	r19, Y+5	; 0x05
    133c:	82 17       	cp	r24, r18
    133e:	93 07       	cpc	r25, r19
    1340:	18 f1       	brcs	.+70     	; 0x1388 <prvCopyDataToQueue+0x80>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1342:	88 81       	ld	r24, Y
    1344:	99 81       	ldd	r25, Y+1	; 0x01
    1346:	9b 83       	std	Y+3, r25	; 0x03
    1348:	8a 83       	std	Y+2, r24	; 0x02
    134a:	1e c0       	rjmp	.+60     	; 0x1388 <prvCopyDataToQueue+0x80>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    134c:	8e 81       	ldd	r24, Y+6	; 0x06
    134e:	9f 81       	ldd	r25, Y+7	; 0x07
    1350:	0e 94 94 12 	call	0x2528	; 0x2528 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1354:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	91 95       	neg	r25
    135a:	81 95       	neg	r24
    135c:	91 09       	sbc	r25, r1
    135e:	2e 81       	ldd	r18, Y+6	; 0x06
    1360:	3f 81       	ldd	r19, Y+7	; 0x07
    1362:	28 0f       	add	r18, r24
    1364:	39 1f       	adc	r19, r25
    1366:	3f 83       	std	Y+7, r19	; 0x07
    1368:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    136a:	48 81       	ld	r20, Y
    136c:	59 81       	ldd	r21, Y+1	; 0x01
    136e:	24 17       	cp	r18, r20
    1370:	35 07       	cpc	r19, r21
    1372:	30 f4       	brcc	.+12     	; 0x1380 <prvCopyDataToQueue+0x78>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1374:	2c 81       	ldd	r18, Y+4	; 0x04
    1376:	3d 81       	ldd	r19, Y+5	; 0x05
    1378:	82 0f       	add	r24, r18
    137a:	93 1f       	adc	r25, r19
    137c:	9f 83       	std	Y+7, r25	; 0x07
    137e:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1380:	02 30       	cpi	r16, 0x02	; 2
    1382:	11 f4       	brne	.+4      	; 0x1388 <prvCopyDataToQueue+0x80>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1384:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1386:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1388:	1f 5f       	subi	r17, 0xFF	; 255
    138a:	1a 8f       	std	Y+26, r17	; 0x1a

	return xReturn;
}
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	df 91       	pop	r29
    1390:	cf 91       	pop	r28
    1392:	1f 91       	pop	r17
    1394:	0f 91       	pop	r16
    1396:	08 95       	ret

00001398 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1398:	fc 01       	movw	r30, r24
    139a:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    139c:	44 8d       	ldd	r20, Z+28	; 0x1c
    139e:	44 23       	and	r20, r20
    13a0:	a1 f0       	breq	.+40     	; 0x13ca <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    13a2:	50 e0       	ldi	r21, 0x00	; 0
    13a4:	26 81       	ldd	r18, Z+6	; 0x06
    13a6:	37 81       	ldd	r19, Z+7	; 0x07
    13a8:	24 0f       	add	r18, r20
    13aa:	35 1f       	adc	r19, r21
    13ac:	37 83       	std	Z+7, r19	; 0x07
    13ae:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    13b0:	64 81       	ldd	r22, Z+4	; 0x04
    13b2:	75 81       	ldd	r23, Z+5	; 0x05
    13b4:	26 17       	cp	r18, r22
    13b6:	37 07       	cpc	r19, r23
    13b8:	20 f0       	brcs	.+8      	; 0x13c2 <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    13ba:	20 81       	ld	r18, Z
    13bc:	31 81       	ldd	r19, Z+1	; 0x01
    13be:	37 83       	std	Z+7, r19	; 0x07
    13c0:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    13c2:	66 81       	ldd	r22, Z+6	; 0x06
    13c4:	77 81       	ldd	r23, Z+7	; 0x07
    13c6:	0c 94 94 12 	jmp	0x2528	; 0x2528 <memcpy>
    13ca:	08 95       	ret

000013cc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    13cc:	ef 92       	push	r14
    13ce:	ff 92       	push	r15
    13d0:	1f 93       	push	r17
    13d2:	cf 93       	push	r28
    13d4:	df 93       	push	r29
    13d6:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	f8 94       	cli
    13dc:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    13de:	1e 8d       	ldd	r17, Y+30	; 0x1e
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13e0:	7c 01       	movw	r14, r24
    13e2:	81 e1       	ldi	r24, 0x11	; 17
    13e4:	e8 0e       	add	r14, r24
    13e6:	f1 1c       	adc	r15, r1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    13e8:	11 16       	cp	r1, r17
    13ea:	5c f4       	brge	.+22     	; 0x1402 <prvUnlockQueue+0x36>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13ec:	89 89       	ldd	r24, Y+17	; 0x11
    13ee:	88 23       	and	r24, r24
    13f0:	41 f0       	breq	.+16     	; 0x1402 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13f2:	c7 01       	movw	r24, r14
    13f4:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    13f8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    13fa:	0e 94 37 07 	call	0xe6e	; 0xe6e <vTaskMissedYield>
    13fe:	11 50       	subi	r17, 0x01	; 1
    1400:	f3 cf       	rjmp	.-26     	; 0x13e8 <prvUnlockQueue+0x1c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1402:	8f ef       	ldi	r24, 0xFF	; 255
    1404:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1406:	0f 90       	pop	r0
    1408:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1410:	1d 8d       	ldd	r17, Y+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1412:	7e 01       	movw	r14, r28
    1414:	88 e0       	ldi	r24, 0x08	; 8
    1416:	e8 0e       	add	r14, r24
    1418:	f1 1c       	adc	r15, r1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    141a:	11 16       	cp	r1, r17
    141c:	5c f4       	brge	.+22     	; 0x1434 <prvUnlockQueue+0x68>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    141e:	88 85       	ldd	r24, Y+8	; 0x08
    1420:	88 23       	and	r24, r24
    1422:	41 f0       	breq	.+16     	; 0x1434 <prvUnlockQueue+0x68>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1424:	c7 01       	movw	r24, r14
    1426:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    142a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    142c:	0e 94 37 07 	call	0xe6e	; 0xe6e <vTaskMissedYield>
    1430:	11 50       	subi	r17, 0x01	; 1
    1432:	f3 cf       	rjmp	.-26     	; 0x141a <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1434:	8f ef       	ldi	r24, 0xFF	; 255
    1436:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1438:	0f 90       	pop	r0
    143a:	0f be       	out	0x3f, r0	; 63
}
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	1f 91       	pop	r17
    1442:	ff 90       	pop	r15
    1444:	ef 90       	pop	r14
    1446:	08 95       	ret

00001448 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    144e:	0f b6       	in	r0, 0x3f	; 63
    1450:	f8 94       	cli
    1452:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1454:	48 81       	ld	r20, Y
    1456:	59 81       	ldd	r21, Y+1	; 0x01
    1458:	8b 8d       	ldd	r24, Y+27	; 0x1b
    145a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    145c:	9a 01       	movw	r18, r20
    145e:	87 9f       	mul	r24, r23
    1460:	20 0d       	add	r18, r0
    1462:	31 1d       	adc	r19, r1
    1464:	11 24       	eor	r1, r1
    1466:	3d 83       	std	Y+5, r19	; 0x05
    1468:	2c 83       	std	Y+4, r18	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    146a:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    146c:	5b 83       	std	Y+3, r21	; 0x03
    146e:	4a 83       	std	Y+2, r20	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	01 97       	sbiw	r24, 0x01	; 1
    1474:	78 9f       	mul	r23, r24
    1476:	90 01       	movw	r18, r0
    1478:	79 9f       	mul	r23, r25
    147a:	30 0d       	add	r19, r0
    147c:	11 24       	eor	r1, r1
    147e:	ca 01       	movw	r24, r20
    1480:	82 0f       	add	r24, r18
    1482:	93 1f       	adc	r25, r19
    1484:	9f 83       	std	Y+7, r25	; 0x07
    1486:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1488:	8f ef       	ldi	r24, 0xFF	; 255
    148a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    148c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    148e:	61 11       	cpse	r22, r1
    1490:	0c c0       	rjmp	.+24     	; 0x14aa <xQueueGenericReset+0x62>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1492:	88 85       	ldd	r24, Y+8	; 0x08
    1494:	88 23       	and	r24, r24
    1496:	89 f0       	breq	.+34     	; 0x14ba <xQueueGenericReset+0x72>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1498:	ce 01       	movw	r24, r28
    149a:	08 96       	adiw	r24, 0x08	; 8
    149c:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    14a0:	88 23       	and	r24, r24
    14a2:	59 f0       	breq	.+22     	; 0x14ba <xQueueGenericReset+0x72>
				{
					queueYIELD_IF_USING_PREEMPTION();
    14a4:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    14a8:	08 c0       	rjmp	.+16     	; 0x14ba <xQueueGenericReset+0x72>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    14aa:	ce 01       	movw	r24, r28
    14ac:	08 96       	adiw	r24, 0x08	; 8
    14ae:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    14b2:	ce 01       	movw	r24, r28
    14b4:	41 96       	adiw	r24, 0x11	; 17
    14b6:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    14ba:	0f 90       	pop	r0
    14bc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	08 95       	ret

000014c6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    14c6:	0f 93       	push	r16
    14c8:	1f 93       	push	r17
    14ca:	cf 93       	push	r28
    14cc:	df 93       	push	r29
    14ce:	08 2f       	mov	r16, r24
    14d0:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    14d2:	66 23       	and	r22, r22
    14d4:	21 f0       	breq	.+8      	; 0x14de <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14d6:	86 9f       	mul	r24, r22
    14d8:	c0 01       	movw	r24, r0
    14da:	11 24       	eor	r1, r1
    14dc:	02 c0       	rjmp	.+4      	; 0x14e2 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    14de:	80 e0       	ldi	r24, 0x00	; 0
    14e0:	90 e0       	ldi	r25, 0x00	; 0
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    14e2:	4f 96       	adiw	r24, 0x1f	; 31
    14e4:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    14e8:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    14ea:	00 97       	sbiw	r24, 0x00	; 0
    14ec:	71 f0       	breq	.+28     	; 0x150a <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    14ee:	11 11       	cpse	r17, r1
    14f0:	03 c0       	rjmp	.+6      	; 0x14f8 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    14f2:	99 83       	std	Y+1, r25	; 0x01
    14f4:	88 83       	st	Y, r24
    14f6:	03 c0       	rjmp	.+6      	; 0x14fe <xQueueGenericCreate+0x38>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    14f8:	4f 96       	adiw	r24, 0x1f	; 31
    14fa:	99 83       	std	Y+1, r25	; 0x01
    14fc:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    14fe:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1500:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1502:	61 e0       	ldi	r22, 0x01	; 1
    1504:	ce 01       	movw	r24, r28
    1506:	0e 94 24 0a 	call	0x1448	; 0x1448 <xQueueGenericReset>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    150a:	ce 01       	movw	r24, r28
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	1f 91       	pop	r17
    1512:	0f 91       	pop	r16
    1514:	08 95       	ret

00001516 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1516:	af 92       	push	r10
    1518:	bf 92       	push	r11
    151a:	cf 92       	push	r12
    151c:	df 92       	push	r13
    151e:	ff 92       	push	r15
    1520:	0f 93       	push	r16
    1522:	1f 93       	push	r17
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	00 d0       	rcall	.+0      	; 0x152a <xQueueGenericSend+0x14>
    152a:	00 d0       	rcall	.+0      	; 0x152c <xQueueGenericSend+0x16>
    152c:	1f 92       	push	r1
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
    1532:	8c 01       	movw	r16, r24
    1534:	6b 01       	movw	r12, r22
    1536:	5d 83       	std	Y+5, r21	; 0x05
    1538:	4c 83       	std	Y+4, r20	; 0x04
    153a:	f2 2e       	mov	r15, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    153c:	80 e0       	ldi	r24, 0x00	; 0
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    153e:	58 01       	movw	r10, r16
    1540:	98 e0       	ldi	r25, 0x08	; 8
    1542:	a9 0e       	add	r10, r25
    1544:	b1 1c       	adc	r11, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1546:	0f b6       	in	r0, 0x3f	; 63
    1548:	f8 94       	cli
    154a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    154c:	f8 01       	movw	r30, r16
    154e:	22 8d       	ldd	r18, Z+26	; 0x1a
    1550:	93 8d       	ldd	r25, Z+27	; 0x1b
    1552:	29 17       	cp	r18, r25
    1554:	18 f0       	brcs	.+6      	; 0x155c <xQueueGenericSend+0x46>
    1556:	f2 e0       	ldi	r31, 0x02	; 2
    1558:	ff 12       	cpse	r15, r31
    155a:	14 c0       	rjmp	.+40     	; 0x1584 <xQueueGenericSend+0x6e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    155c:	4f 2d       	mov	r20, r15
    155e:	b6 01       	movw	r22, r12
    1560:	c8 01       	movw	r24, r16
    1562:	0e 94 84 09 	call	0x1308	; 0x1308 <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1566:	f8 01       	movw	r30, r16
    1568:	91 89       	ldd	r25, Z+17	; 0x11
    156a:	99 23       	and	r25, r25
    156c:	21 f0       	breq	.+8      	; 0x1576 <xQueueGenericSend+0x60>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    156e:	c8 01       	movw	r24, r16
    1570:	41 96       	adiw	r24, 0x11	; 17
    1572:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    1576:	81 11       	cpse	r24, r1
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1578:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1580:	81 e0       	ldi	r24, 0x01	; 1
    1582:	50 c0       	rjmp	.+160    	; 0x1624 <xQueueGenericSend+0x10e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1584:	2c 81       	ldd	r18, Y+4	; 0x04
    1586:	3d 81       	ldd	r19, Y+5	; 0x05
    1588:	23 2b       	or	r18, r19
    158a:	19 f4       	brne	.+6      	; 0x1592 <xQueueGenericSend+0x7c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	48 c0       	rjmp	.+144    	; 0x1622 <xQueueGenericSend+0x10c>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1592:	81 11       	cpse	r24, r1
    1594:	04 c0       	rjmp	.+8      	; 0x159e <xQueueGenericSend+0x88>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1596:	ce 01       	movw	r24, r28
    1598:	01 96       	adiw	r24, 0x01	; 1
    159a:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    15a2:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	f8 94       	cli
    15aa:	0f 92       	push	r0
    15ac:	f8 01       	movw	r30, r16
    15ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    15b0:	8f 3f       	cpi	r24, 0xFF	; 255
    15b2:	09 f4       	brne	.+2      	; 0x15b6 <xQueueGenericSend+0xa0>
    15b4:	15 8e       	std	Z+29, r1	; 0x1d
    15b6:	f8 01       	movw	r30, r16
    15b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    15ba:	8f 3f       	cpi	r24, 0xFF	; 255
    15bc:	09 f4       	brne	.+2      	; 0x15c0 <xQueueGenericSend+0xaa>
    15be:	16 8e       	std	Z+30, r1	; 0x1e
    15c0:	0f 90       	pop	r0
    15c2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15c4:	be 01       	movw	r22, r28
    15c6:	6c 5f       	subi	r22, 0xFC	; 252
    15c8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ca:	ce 01       	movw	r24, r28
    15cc:	01 96       	adiw	r24, 0x01	; 1
    15ce:	0e 94 04 07 	call	0xe08	; 0xe08 <xTaskCheckForTimeOut>
    15d2:	81 11       	cpse	r24, r1
    15d4:	21 c0       	rjmp	.+66     	; 0x1618 <xQueueGenericSend+0x102>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    15d6:	0f b6       	in	r0, 0x3f	; 63
    15d8:	f8 94       	cli
    15da:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    15dc:	f8 01       	movw	r30, r16
    15de:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    15e0:	0f 90       	pop	r0
    15e2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    15e6:	98 13       	cpse	r25, r24
    15e8:	11 c0       	rjmp	.+34     	; 0x160c <xQueueGenericSend+0xf6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15ea:	6c 81       	ldd	r22, Y+4	; 0x04
    15ec:	7d 81       	ldd	r23, Y+5	; 0x05
    15ee:	c5 01       	movw	r24, r10
    15f0:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    15f4:	c8 01       	movw	r24, r16
    15f6:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    15fa:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    15fe:	88 23       	and	r24, r24
    1600:	11 f0       	breq	.+4      	; 0x1606 <xQueueGenericSend+0xf0>
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	a0 cf       	rjmp	.-192    	; 0x1546 <xQueueGenericSend+0x30>
				{
					portYIELD_WITHIN_API();
    1606:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    160a:	fb cf       	rjmp	.-10     	; 0x1602 <xQueueGenericSend+0xec>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    160c:	c8 01       	movw	r24, r16
    160e:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1612:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    1616:	f5 cf       	rjmp	.-22     	; 0x1602 <xQueueGenericSend+0xec>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1618:	c8 01       	movw	r24, r16
    161a:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    161e:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1622:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    1624:	0f 90       	pop	r0
    1626:	0f 90       	pop	r0
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	0f 90       	pop	r0
    162e:	df 91       	pop	r29
    1630:	cf 91       	pop	r28
    1632:	1f 91       	pop	r17
    1634:	0f 91       	pop	r16
    1636:	ff 90       	pop	r15
    1638:	df 90       	pop	r13
    163a:	cf 90       	pop	r12
    163c:	bf 90       	pop	r11
    163e:	af 90       	pop	r10
    1640:	08 95       	ret

00001642 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1642:	ef 92       	push	r14
    1644:	ff 92       	push	r15
    1646:	1f 93       	push	r17
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	ec 01       	movw	r28, r24
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    164e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1650:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1652:	98 17       	cp	r25, r24
    1654:	10 f0       	brcs	.+4      	; 0x165a <xQueueGenericSendFromISR+0x18>
    1656:	22 30       	cpi	r18, 0x02	; 2
    1658:	e1 f4       	brne	.+56     	; 0x1692 <xQueueGenericSendFromISR+0x50>
    165a:	7a 01       	movw	r14, r20
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    165c:	1e 8d       	ldd	r17, Y+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    165e:	42 2f       	mov	r20, r18
    1660:	ce 01       	movw	r24, r28
    1662:	0e 94 84 09 	call	0x1308	; 0x1308 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1666:	1f 3f       	cpi	r17, 0xFF	; 255
    1668:	81 f4       	brne	.+32     	; 0x168a <xQueueGenericSendFromISR+0x48>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    166a:	89 89       	ldd	r24, Y+17	; 0x11
    166c:	88 23       	and	r24, r24
    166e:	79 f0       	breq	.+30     	; 0x168e <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1670:	ce 01       	movw	r24, r28
    1672:	41 96       	adiw	r24, 0x11	; 17
    1674:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    1678:	88 23       	and	r24, r24
    167a:	49 f0       	breq	.+18     	; 0x168e <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    167c:	e1 14       	cp	r14, r1
    167e:	f1 04       	cpc	r15, r1
    1680:	31 f0       	breq	.+12     	; 0x168e <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	f7 01       	movw	r30, r14
    1686:	80 83       	st	Z, r24
    1688:	05 c0       	rjmp	.+10     	; 0x1694 <xQueueGenericSendFromISR+0x52>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    168a:	1f 5f       	subi	r17, 0xFF	; 255
    168c:	1e 8f       	std	Y+30, r17	; 0x1e
			}

			xReturn = pdPASS;
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	01 c0       	rjmp	.+2      	; 0x1694 <xQueueGenericSendFromISR+0x52>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1692:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1694:	df 91       	pop	r29
    1696:	cf 91       	pop	r28
    1698:	1f 91       	pop	r17
    169a:	ff 90       	pop	r15
    169c:	ef 90       	pop	r14
    169e:	08 95       	ret

000016a0 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    16a6:	92 8d       	ldd	r25, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    16a8:	83 8d       	ldd	r24, Z+27	; 0x1b
    16aa:	98 17       	cp	r25, r24
    16ac:	c0 f4       	brcc	.+48     	; 0x16de <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    16ae:	86 8d       	ldd	r24, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    16b0:	9f 5f       	subi	r25, 0xFF	; 255
    16b2:	92 8f       	std	Z+26, r25	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    16b4:	8f 3f       	cpi	r24, 0xFF	; 255
    16b6:	79 f4       	brne	.+30     	; 0x16d6 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16b8:	81 89       	ldd	r24, Z+17	; 0x11
    16ba:	88 23       	and	r24, r24
    16bc:	71 f0       	breq	.+28     	; 0x16da <xQueueGiveFromISR+0x3a>
    16be:	eb 01       	movw	r28, r22
    16c0:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16c2:	41 96       	adiw	r24, 0x11	; 17
    16c4:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    16c8:	88 23       	and	r24, r24
    16ca:	39 f0       	breq	.+14     	; 0x16da <xQueueGiveFromISR+0x3a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16cc:	20 97       	sbiw	r28, 0x00	; 0
    16ce:	29 f0       	breq	.+10     	; 0x16da <xQueueGiveFromISR+0x3a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16d0:	81 e0       	ldi	r24, 0x01	; 1
    16d2:	88 83       	st	Y, r24
    16d4:	05 c0       	rjmp	.+10     	; 0x16e0 <xQueueGiveFromISR+0x40>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    16d6:	8f 5f       	subi	r24, 0xFF	; 255
    16d8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	01 c0       	rjmp	.+2      	; 0x16e0 <xQueueGiveFromISR+0x40>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    16de:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    16e0:	df 91       	pop	r29
    16e2:	cf 91       	pop	r28
    16e4:	08 95       	ret

000016e6 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    16e6:	af 92       	push	r10
    16e8:	bf 92       	push	r11
    16ea:	cf 92       	push	r12
    16ec:	df 92       	push	r13
    16ee:	ff 92       	push	r15
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	00 d0       	rcall	.+0      	; 0x16fa <xQueueReceive+0x14>
    16fa:	00 d0       	rcall	.+0      	; 0x16fc <xQueueReceive+0x16>
    16fc:	1f 92       	push	r1
    16fe:	cd b7       	in	r28, 0x3d	; 61
    1700:	de b7       	in	r29, 0x3e	; 62
    1702:	8c 01       	movw	r16, r24
    1704:	6b 01       	movw	r12, r22
    1706:	5d 83       	std	Y+5, r21	; 0x05
    1708:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    170a:	80 e0       	ldi	r24, 0x00	; 0
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    170c:	58 01       	movw	r10, r16
    170e:	91 e1       	ldi	r25, 0x11	; 17
    1710:	a9 0e       	add	r10, r25
    1712:	b1 1c       	adc	r11, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    171a:	f8 01       	movw	r30, r16
    171c:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    171e:	ff 20       	and	r15, r15
    1720:	a9 f0       	breq	.+42     	; 0x174c <xQueueReceive+0x66>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1722:	b6 01       	movw	r22, r12
    1724:	c8 01       	movw	r24, r16
    1726:	0e 94 cc 09 	call	0x1398	; 0x1398 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    172a:	fa 94       	dec	r15
    172c:	f8 01       	movw	r30, r16
    172e:	f2 8e       	std	Z+26, r15	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1730:	80 85       	ldd	r24, Z+8	; 0x08
    1732:	88 23       	and	r24, r24
    1734:	39 f0       	breq	.+14     	; 0x1744 <xQueueReceive+0x5e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1736:	c8 01       	movw	r24, r16
    1738:	08 96       	adiw	r24, 0x08	; 8
    173a:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    173e:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1740:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1744:	0f 90       	pop	r0
    1746:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1748:	81 e0       	ldi	r24, 0x01	; 1
    174a:	50 c0       	rjmp	.+160    	; 0x17ec <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    174c:	2c 81       	ldd	r18, Y+4	; 0x04
    174e:	3d 81       	ldd	r19, Y+5	; 0x05
    1750:	23 2b       	or	r18, r19
    1752:	19 f4       	brne	.+6      	; 0x175a <xQueueReceive+0x74>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	48 c0       	rjmp	.+144    	; 0x17ea <xQueueReceive+0x104>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    175a:	81 11       	cpse	r24, r1
    175c:	04 c0       	rjmp	.+8      	; 0x1766 <xQueueReceive+0x80>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    175e:	ce 01       	movw	r24, r28
    1760:	01 96       	adiw	r24, 0x01	; 1
    1762:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1766:	0f 90       	pop	r0
    1768:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    176a:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    176e:	0f b6       	in	r0, 0x3f	; 63
    1770:	f8 94       	cli
    1772:	0f 92       	push	r0
    1774:	f8 01       	movw	r30, r16
    1776:	85 8d       	ldd	r24, Z+29	; 0x1d
    1778:	8f 3f       	cpi	r24, 0xFF	; 255
    177a:	09 f4       	brne	.+2      	; 0x177e <xQueueReceive+0x98>
    177c:	15 8e       	std	Z+29, r1	; 0x1d
    177e:	f8 01       	movw	r30, r16
    1780:	86 8d       	ldd	r24, Z+30	; 0x1e
    1782:	8f 3f       	cpi	r24, 0xFF	; 255
    1784:	09 f4       	brne	.+2      	; 0x1788 <xQueueReceive+0xa2>
    1786:	16 8e       	std	Z+30, r1	; 0x1e
    1788:	0f 90       	pop	r0
    178a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    178c:	be 01       	movw	r22, r28
    178e:	6c 5f       	subi	r22, 0xFC	; 252
    1790:	7f 4f       	sbci	r23, 0xFF	; 255
    1792:	ce 01       	movw	r24, r28
    1794:	01 96       	adiw	r24, 0x01	; 1
    1796:	0e 94 04 07 	call	0xe08	; 0xe08 <xTaskCheckForTimeOut>
    179a:	81 11       	cpse	r24, r1
    179c:	1c c0       	rjmp	.+56     	; 0x17d6 <xQueueReceive+0xf0>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    179e:	c8 01       	movw	r24, r16
    17a0:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    17a4:	88 23       	and	r24, r24
    17a6:	89 f0       	breq	.+34     	; 0x17ca <xQueueReceive+0xe4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17a8:	6c 81       	ldd	r22, Y+4	; 0x04
    17aa:	7d 81       	ldd	r23, Y+5	; 0x05
    17ac:	c5 01       	movw	r24, r10
    17ae:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    17b2:	c8 01       	movw	r24, r16
    17b4:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    17b8:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    17bc:	88 23       	and	r24, r24
    17be:	11 f0       	breq	.+4      	; 0x17c4 <xQueueReceive+0xde>
    17c0:	81 e0       	ldi	r24, 0x01	; 1
    17c2:	a8 cf       	rjmp	.-176    	; 0x1714 <xQueueReceive+0x2e>
				{
					portYIELD_WITHIN_API();
    17c4:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    17c8:	fb cf       	rjmp	.-10     	; 0x17c0 <xQueueReceive+0xda>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    17ca:	c8 01       	movw	r24, r16
    17cc:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    17d0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    17d4:	f5 cf       	rjmp	.-22     	; 0x17c0 <xQueueReceive+0xda>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    17d6:	c8 01       	movw	r24, r16
    17d8:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    17dc:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17e0:	c8 01       	movw	r24, r16
    17e2:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    17e6:	88 23       	and	r24, r24
    17e8:	59 f3       	breq	.-42     	; 0x17c0 <xQueueReceive+0xda>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    17ea:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    17ec:	0f 90       	pop	r0
    17ee:	0f 90       	pop	r0
    17f0:	0f 90       	pop	r0
    17f2:	0f 90       	pop	r0
    17f4:	0f 90       	pop	r0
    17f6:	df 91       	pop	r29
    17f8:	cf 91       	pop	r28
    17fa:	1f 91       	pop	r17
    17fc:	0f 91       	pop	r16
    17fe:	ff 90       	pop	r15
    1800:	df 90       	pop	r13
    1802:	cf 90       	pop	r12
    1804:	bf 90       	pop	r11
    1806:	af 90       	pop	r10
    1808:	08 95       	ret

0000180a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    180a:	ef 92       	push	r14
    180c:	ff 92       	push	r15
    180e:	0f 93       	push	r16
    1810:	1f 93       	push	r17
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
    1816:	00 d0       	rcall	.+0      	; 0x1818 <xQueueSemaphoreTake+0xe>
    1818:	00 d0       	rcall	.+0      	; 0x181a <xQueueSemaphoreTake+0x10>
    181a:	1f 92       	push	r1
    181c:	cd b7       	in	r28, 0x3d	; 61
    181e:	de b7       	in	r29, 0x3e	; 62
    1820:	8c 01       	movw	r16, r24
    1822:	7d 83       	std	Y+5, r23	; 0x05
    1824:	6c 83       	std	Y+4, r22	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1826:	90 e0       	ldi	r25, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1828:	78 01       	movw	r14, r16
    182a:	81 e1       	ldi	r24, 0x11	; 17
    182c:	e8 0e       	add	r14, r24
    182e:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1830:	0f b6       	in	r0, 0x3f	; 63
    1832:	f8 94       	cli
    1834:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1836:	f8 01       	movw	r30, r16
    1838:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    183a:	88 23       	and	r24, r24
    183c:	81 f0       	breq	.+32     	; 0x185e <xQueueSemaphoreTake+0x54>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    183e:	81 50       	subi	r24, 0x01	; 1
    1840:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1842:	80 85       	ldd	r24, Z+8	; 0x08
    1844:	88 23       	and	r24, r24
    1846:	39 f0       	breq	.+14     	; 0x1856 <xQueueSemaphoreTake+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1848:	c8 01       	movw	r24, r16
    184a:	08 96       	adiw	r24, 0x08	; 8
    184c:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    1850:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    1852:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1856:	0f 90       	pop	r0
    1858:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	50 c0       	rjmp	.+160    	; 0x18fe <xQueueSemaphoreTake+0xf4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    185e:	2c 81       	ldd	r18, Y+4	; 0x04
    1860:	3d 81       	ldd	r19, Y+5	; 0x05
    1862:	23 2b       	or	r18, r19
    1864:	19 f4       	brne	.+6      	; 0x186c <xQueueSemaphoreTake+0x62>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1866:	0f 90       	pop	r0
    1868:	0f be       	out	0x3f, r0	; 63
    186a:	48 c0       	rjmp	.+144    	; 0x18fc <xQueueSemaphoreTake+0xf2>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    186c:	91 11       	cpse	r25, r1
    186e:	04 c0       	rjmp	.+8      	; 0x1878 <xQueueSemaphoreTake+0x6e>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1870:	ce 01       	movw	r24, r28
    1872:	01 96       	adiw	r24, 0x01	; 1
    1874:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1878:	0f 90       	pop	r0
    187a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    187c:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1880:	0f b6       	in	r0, 0x3f	; 63
    1882:	f8 94       	cli
    1884:	0f 92       	push	r0
    1886:	f8 01       	movw	r30, r16
    1888:	85 8d       	ldd	r24, Z+29	; 0x1d
    188a:	8f 3f       	cpi	r24, 0xFF	; 255
    188c:	09 f4       	brne	.+2      	; 0x1890 <xQueueSemaphoreTake+0x86>
    188e:	15 8e       	std	Z+29, r1	; 0x1d
    1890:	f8 01       	movw	r30, r16
    1892:	86 8d       	ldd	r24, Z+30	; 0x1e
    1894:	8f 3f       	cpi	r24, 0xFF	; 255
    1896:	09 f4       	brne	.+2      	; 0x189a <xQueueSemaphoreTake+0x90>
    1898:	16 8e       	std	Z+30, r1	; 0x1e
    189a:	0f 90       	pop	r0
    189c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    189e:	be 01       	movw	r22, r28
    18a0:	6c 5f       	subi	r22, 0xFC	; 252
    18a2:	7f 4f       	sbci	r23, 0xFF	; 255
    18a4:	ce 01       	movw	r24, r28
    18a6:	01 96       	adiw	r24, 0x01	; 1
    18a8:	0e 94 04 07 	call	0xe08	; 0xe08 <xTaskCheckForTimeOut>
    18ac:	81 11       	cpse	r24, r1
    18ae:	1c c0       	rjmp	.+56     	; 0x18e8 <xQueueSemaphoreTake+0xde>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18b0:	c8 01       	movw	r24, r16
    18b2:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    18b6:	88 23       	and	r24, r24
    18b8:	89 f0       	breq	.+34     	; 0x18dc <xQueueSemaphoreTake+0xd2>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    18ba:	6c 81       	ldd	r22, Y+4	; 0x04
    18bc:	7d 81       	ldd	r23, Y+5	; 0x05
    18be:	c7 01       	movw	r24, r14
    18c0:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    18c4:	c8 01       	movw	r24, r16
    18c6:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    18ca:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    18ce:	88 23       	and	r24, r24
    18d0:	11 f0       	breq	.+4      	; 0x18d6 <xQueueSemaphoreTake+0xcc>
    18d2:	91 e0       	ldi	r25, 0x01	; 1
    18d4:	ad cf       	rjmp	.-166    	; 0x1830 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    18d6:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    18da:	fb cf       	rjmp	.-10     	; 0x18d2 <xQueueSemaphoreTake+0xc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    18dc:	c8 01       	movw	r24, r16
    18de:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    18e2:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    18e6:	f5 cf       	rjmp	.-22     	; 0x18d2 <xQueueSemaphoreTake+0xc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    18e8:	c8 01       	movw	r24, r16
    18ea:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18ee:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    18f2:	c8 01       	movw	r24, r16
    18f4:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    18f8:	88 23       	and	r24, r24
    18fa:	59 f3       	breq	.-42     	; 0x18d2 <xQueueSemaphoreTake+0xc8>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    18fc:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    18fe:	0f 90       	pop	r0
    1900:	0f 90       	pop	r0
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	0f 90       	pop	r0
    1908:	df 91       	pop	r29
    190a:	cf 91       	pop	r28
    190c:	1f 91       	pop	r17
    190e:	0f 91       	pop	r16
    1910:	ff 90       	pop	r15
    1912:	ef 90       	pop	r14
    1914:	08 95       	ret

00001916 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1916:	cf 92       	push	r12
    1918:	df 92       	push	r13
    191a:	ef 92       	push	r14
    191c:	ff 92       	push	r15
    191e:	0f 93       	push	r16
    1920:	1f 93       	push	r17
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
    1926:	00 d0       	rcall	.+0      	; 0x1928 <xQueuePeek+0x12>
    1928:	00 d0       	rcall	.+0      	; 0x192a <xQueuePeek+0x14>
    192a:	1f 92       	push	r1
    192c:	cd b7       	in	r28, 0x3d	; 61
    192e:	de b7       	in	r29, 0x3e	; 62
    1930:	8c 01       	movw	r16, r24
    1932:	7b 01       	movw	r14, r22
    1934:	5d 83       	std	Y+5, r21	; 0x05
    1936:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
    1938:	80 e0       	ldi	r24, 0x00	; 0
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    193a:	68 01       	movw	r12, r16
    193c:	91 e1       	ldi	r25, 0x11	; 17
    193e:	c9 0e       	add	r12, r25
    1940:	d1 1c       	adc	r13, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1942:	0f b6       	in	r0, 0x3f	; 63
    1944:	f8 94       	cli
    1946:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1948:	f8 01       	movw	r30, r16
    194a:	92 8d       	ldd	r25, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    194c:	99 23       	and	r25, r25
    194e:	b9 f0       	breq	.+46     	; 0x197e <xQueuePeek+0x68>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1950:	c6 80       	ldd	r12, Z+6	; 0x06
    1952:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1954:	b7 01       	movw	r22, r14
    1956:	c8 01       	movw	r24, r16
    1958:	0e 94 cc 09 	call	0x1398	; 0x1398 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    195c:	f8 01       	movw	r30, r16
    195e:	d7 82       	std	Z+7, r13	; 0x07
    1960:	c6 82       	std	Z+6, r12	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1962:	81 89       	ldd	r24, Z+17	; 0x11
    1964:	88 23       	and	r24, r24
    1966:	39 f0       	breq	.+14     	; 0x1976 <xQueuePeek+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1968:	c8 01       	movw	r24, r16
    196a:	41 96       	adiw	r24, 0x11	; 17
    196c:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    1970:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    1972:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	50 c0       	rjmp	.+160    	; 0x1a1e <xQueuePeek+0x108>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    197e:	2c 81       	ldd	r18, Y+4	; 0x04
    1980:	3d 81       	ldd	r19, Y+5	; 0x05
    1982:	23 2b       	or	r18, r19
    1984:	19 f4       	brne	.+6      	; 0x198c <xQueuePeek+0x76>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	48 c0       	rjmp	.+144    	; 0x1a1c <xQueuePeek+0x106>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    198c:	81 11       	cpse	r24, r1
    198e:	04 c0       	rjmp	.+8      	; 0x1998 <xQueuePeek+0x82>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1990:	ce 01       	movw	r24, r28
    1992:	01 96       	adiw	r24, 0x01	; 1
    1994:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskInternalSetTimeOutState>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    199c:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	0f 92       	push	r0
    19a6:	f8 01       	movw	r30, r16
    19a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    19aa:	8f 3f       	cpi	r24, 0xFF	; 255
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <xQueuePeek+0x9a>
    19ae:	15 8e       	std	Z+29, r1	; 0x1d
    19b0:	f8 01       	movw	r30, r16
    19b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    19b4:	8f 3f       	cpi	r24, 0xFF	; 255
    19b6:	09 f4       	brne	.+2      	; 0x19ba <xQueuePeek+0xa4>
    19b8:	16 8e       	std	Z+30, r1	; 0x1e
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19be:	be 01       	movw	r22, r28
    19c0:	6c 5f       	subi	r22, 0xFC	; 252
    19c2:	7f 4f       	sbci	r23, 0xFF	; 255
    19c4:	ce 01       	movw	r24, r28
    19c6:	01 96       	adiw	r24, 0x01	; 1
    19c8:	0e 94 04 07 	call	0xe08	; 0xe08 <xTaskCheckForTimeOut>
    19cc:	81 11       	cpse	r24, r1
    19ce:	1c c0       	rjmp	.+56     	; 0x1a08 <xQueuePeek+0xf2>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19d0:	c8 01       	movw	r24, r16
    19d2:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    19d6:	88 23       	and	r24, r24
    19d8:	89 f0       	breq	.+34     	; 0x19fc <xQueuePeek+0xe6>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    19da:	6c 81       	ldd	r22, Y+4	; 0x04
    19dc:	7d 81       	ldd	r23, Y+5	; 0x05
    19de:	c6 01       	movw	r24, r12
    19e0:	0e 94 4e 06 	call	0xc9c	; 0xc9c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    19e4:	c8 01       	movw	r24, r16
    19e6:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    19ea:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    19ee:	88 23       	and	r24, r24
    19f0:	11 f0       	breq	.+4      	; 0x19f6 <xQueuePeek+0xe0>
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	a6 cf       	rjmp	.-180    	; 0x1942 <xQueuePeek+0x2c>
				{
					portYIELD_WITHIN_API();
    19f6:	0e 94 a8 11 	call	0x2350	; 0x2350 <vPortYield>
    19fa:	fb cf       	rjmp	.-10     	; 0x19f2 <xQueuePeek+0xdc>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    19fc:	c8 01       	movw	r24, r16
    19fe:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a02:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
    1a06:	f5 cf       	rjmp	.-22     	; 0x19f2 <xQueuePeek+0xdc>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    1a08:	c8 01       	movw	r24, r16
    1a0a:	0e 94 e6 09 	call	0x13cc	; 0x13cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a0e:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a12:	c8 01       	movw	r24, r16
    1a14:	0e 94 79 09 	call	0x12f2	; 0x12f2 <prvIsQueueEmpty>
    1a18:	88 23       	and	r24, r24
    1a1a:	59 f3       	breq	.-42     	; 0x19f2 <xQueuePeek+0xdc>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1a1c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    1a1e:	0f 90       	pop	r0
    1a20:	0f 90       	pop	r0
    1a22:	0f 90       	pop	r0
    1a24:	0f 90       	pop	r0
    1a26:	0f 90       	pop	r0
    1a28:	df 91       	pop	r29
    1a2a:	cf 91       	pop	r28
    1a2c:	1f 91       	pop	r17
    1a2e:	0f 91       	pop	r16
    1a30:	ff 90       	pop	r15
    1a32:	ef 90       	pop	r14
    1a34:	df 90       	pop	r13
    1a36:	cf 90       	pop	r12
    1a38:	08 95       	ret

00001a3a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1a3a:	ef 92       	push	r14
    1a3c:	ff 92       	push	r15
    1a3e:	0f 93       	push	r16
    1a40:	1f 93       	push	r17
    1a42:	cf 93       	push	r28
    1a44:	df 93       	push	r29
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a46:	fc 01       	movw	r30, r24
    1a48:	02 8d       	ldd	r16, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a4a:	00 23       	and	r16, r16
    1a4c:	e9 f0       	breq	.+58     	; 0x1a88 <xQueueReceiveFromISR+0x4e>
    1a4e:	7a 01       	movw	r14, r20
    1a50:	ec 01       	movw	r28, r24
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1a52:	15 8d       	ldd	r17, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a54:	0e 94 cc 09 	call	0x1398	; 0x1398 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1a58:	01 50       	subi	r16, 0x01	; 1
    1a5a:	0a 8f       	std	Y+26, r16	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1a5c:	1f 3f       	cpi	r17, 0xFF	; 255
    1a5e:	81 f4       	brne	.+32     	; 0x1a80 <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a60:	88 85       	ldd	r24, Y+8	; 0x08
    1a62:	88 23       	and	r24, r24
    1a64:	79 f0       	breq	.+30     	; 0x1a84 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a66:	ce 01       	movw	r24, r28
    1a68:	08 96       	adiw	r24, 0x08	; 8
    1a6a:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskRemoveFromEventList>
    1a6e:	88 23       	and	r24, r24
    1a70:	49 f0       	breq	.+18     	; 0x1a84 <xQueueReceiveFromISR+0x4a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a72:	e1 14       	cp	r14, r1
    1a74:	f1 04       	cpc	r15, r1
    1a76:	31 f0       	breq	.+12     	; 0x1a84 <xQueueReceiveFromISR+0x4a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	f7 01       	movw	r30, r14
    1a7c:	80 83       	st	Z, r24
    1a7e:	05 c0       	rjmp	.+10     	; 0x1a8a <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a80:	1f 5f       	subi	r17, 0xFF	; 255
    1a82:	1d 8f       	std	Y+29, r17	; 0x1d
			}

			xReturn = pdPASS;
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	01 c0       	rjmp	.+2      	; 0x1a8a <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    1a88:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	1f 91       	pop	r17
    1a90:	0f 91       	pop	r16
    1a92:	ff 90       	pop	r15
    1a94:	ef 90       	pop	r14
    1a96:	08 95       	ret

00001a98 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a98:	0f 93       	push	r16
    1a9a:	1f 93       	push	r17
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1aa0:	fc 01       	movw	r30, r24
    1aa2:	22 8d       	ldd	r18, Z+26	; 0x1a
    1aa4:	22 23       	and	r18, r18
    1aa6:	49 f0       	breq	.+18     	; 0x1aba <xQueuePeekFromISR+0x22>
    1aa8:	ec 01       	movw	r28, r24
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1aaa:	06 81       	ldd	r16, Z+6	; 0x06
    1aac:	17 81       	ldd	r17, Z+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aae:	0e 94 cc 09 	call	0x1398	; 0x1398 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1ab2:	1f 83       	std	Y+7, r17	; 0x07
    1ab4:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
    1ab8:	01 c0       	rjmp	.+2      	; 0x1abc <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1aba:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	1f 91       	pop	r17
    1ac2:	0f 91       	pop	r16
    1ac4:	08 95       	ret

00001ac6 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	f8 94       	cli
    1aca:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1acc:	fc 01       	movw	r30, r24
    1ace:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1ad0:	0f 90       	pop	r0
    1ad2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ad4:	08 95       	ret

00001ad6 <uxQueueSpacesAvailable>:
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	f8 94       	cli
    1ada:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1adc:	fc 01       	movw	r30, r24
    1ade:	22 8d       	ldd	r18, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    1ae0:	0f 90       	pop	r0
    1ae2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1ae4:	83 8d       	ldd	r24, Z+27	; 0x1b
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ae6:	82 1b       	sub	r24, r18
    1ae8:	08 95       	ret

00001aea <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1aea:	fc 01       	movw	r30, r24
    1aec:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1aee:	08 95       	ret

00001af0 <vQueueDelete>:

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1af0:	0c 94 ec 10 	jmp	0x21d8	; 0x21d8 <vPortFree>

00001af4 <xQueueIsQueueEmptyFromISR>:
{
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1af4:	fc 01       	movw	r30, r24
    1af6:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1af8:	81 e0       	ldi	r24, 0x01	; 1
    1afa:	91 11       	cpse	r25, r1
    1afc:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1afe:	08 95       	ret

00001b00 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1b00:	fc 01       	movw	r30, r24
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b02:	92 8d       	ldd	r25, Z+26	; 0x1a
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	23 8d       	ldd	r18, Z+27	; 0x1b
    1b08:	29 13       	cpse	r18, r25
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1b0c:	08 95       	ret

00001b0e <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
	{
    1b0e:	cf 93       	push	r28
    1b10:	df 93       	push	r29
    1b12:	ec 01       	movw	r28, r24
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b14:	f8 94       	cli

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1b1c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b1e:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b24:	89 13       	cpse	r24, r25
    1b26:	0f c0       	rjmp	.+30     	; 0x1b46 <xQueueCRSend+0x38>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b28:	41 15       	cp	r20, r1
    1b2a:	51 05       	cpc	r21, r1
    1b2c:	49 f0       	breq	.+18     	; 0x1b40 <xQueueCRSend+0x32>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1b2e:	be 01       	movw	r22, r28
    1b30:	68 5f       	subi	r22, 0xF8	; 248
    1b32:	7f 4f       	sbci	r23, 0xFF	; 255
    1b34:	ca 01       	movw	r24, r20
    1b36:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b3a:	78 94       	sei
					return errQUEUE_BLOCKED;
    1b3c:	8c ef       	ldi	r24, 0xFC	; 252
    1b3e:	1b c0       	rjmp	.+54     	; 0x1b76 <xQueueCRSend+0x68>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1b40:	78 94       	sei
					return errQUEUE_FULL;
    1b42:	80 e0       	ldi	r24, 0x00	; 0
    1b44:	18 c0       	rjmp	.+48     	; 0x1b76 <xQueueCRSend+0x68>
				}
			}
		}
		portENABLE_INTERRUPTS();
    1b46:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1b48:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1b4a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b4c:	89 17       	cp	r24, r25
    1b4e:	88 f4       	brcc	.+34     	; 0x1b72 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1b50:	40 e0       	ldi	r20, 0x00	; 0
    1b52:	ce 01       	movw	r24, r28
    1b54:	0e 94 84 09 	call	0x1308	; 0x1308 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b58:	89 89       	ldd	r24, Y+17	; 0x11
    1b5a:	81 11       	cpse	r24, r1
    1b5c:	02 c0       	rjmp	.+4      	; 0x1b62 <xQueueCRSend+0x54>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
    1b5e:	81 e0       	ldi	r24, 0x01	; 1
    1b60:	09 c0       	rjmp	.+18     	; 0x1b74 <xQueueCRSend+0x66>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b62:	ce 01       	movw	r24, r28
    1b64:	41 96       	adiw	r24, 0x11	; 17
    1b66:	0e 94 95 10 	call	0x212a	; 0x212a <xCoRoutineRemoveFromEventList>
    1b6a:	88 23       	and	r24, r24
    1b6c:	c1 f3       	breq	.-16     	; 0x1b5e <xQueueCRSend+0x50>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
    1b6e:	8b ef       	ldi	r24, 0xFB	; 251
    1b70:	01 c0       	rjmp	.+2      	; 0x1b74 <xQueueCRSend+0x66>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
    1b72:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1b74:	78 94       	sei

		return xReturn;
	}
    1b76:	df 91       	pop	r29
    1b78:	cf 91       	pop	r28
    1b7a:	08 95       	ret

00001b7c <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
	{
    1b7c:	cf 93       	push	r28
    1b7e:	df 93       	push	r29
    1b80:	ec 01       	movw	r28, r24
    1b82:	fb 01       	movw	r30, r22
	Queue_t * const pxQueue = xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1b84:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1b86:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b88:	81 11       	cpse	r24, r1
    1b8a:	0f c0       	rjmp	.+30     	; 0x1baa <xQueueCRReceive+0x2e>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( TickType_t ) 0 )
    1b8c:	41 15       	cp	r20, r1
    1b8e:	51 05       	cpc	r21, r1
    1b90:	49 f0       	breq	.+18     	; 0x1ba4 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    1b92:	be 01       	movw	r22, r28
    1b94:	6f 5e       	subi	r22, 0xEF	; 239
    1b96:	7f 4f       	sbci	r23, 0xFF	; 255
    1b98:	ca 01       	movw	r24, r20
    1b9a:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    1b9e:	78 94       	sei
					return errQUEUE_BLOCKED;
    1ba0:	8c ef       	ldi	r24, 0xFC	; 252
    1ba2:	30 c0       	rjmp	.+96     	; 0x1c04 <xQueueCRReceive+0x88>
				}
				else
				{
					portENABLE_INTERRUPTS();
    1ba4:	78 94       	sei
					return errQUEUE_FULL;
    1ba6:	80 e0       	ldi	r24, 0x00	; 0
    1ba8:	2d c0       	rjmp	.+90     	; 0x1c04 <xQueueCRReceive+0x88>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portENABLE_INTERRUPTS();
    1baa:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1bac:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1bae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bb0:	88 23       	and	r24, r24
    1bb2:	31 f1       	breq	.+76     	; 0x1c00 <xQueueCRReceive+0x84>
			{
				/* Data is available from the queue. */
				pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1bb4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1bb6:	50 e0       	ldi	r21, 0x00	; 0
    1bb8:	2e 81       	ldd	r18, Y+6	; 0x06
    1bba:	3f 81       	ldd	r19, Y+7	; 0x07
    1bbc:	24 0f       	add	r18, r20
    1bbe:	35 1f       	adc	r19, r21
    1bc0:	3f 83       	std	Y+7, r19	; 0x07
    1bc2:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1bc4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bc6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc8:	28 17       	cp	r18, r24
    1bca:	39 07       	cpc	r19, r25
    1bcc:	20 f0       	brcs	.+8      	; 0x1bd6 <xQueueCRReceive+0x5a>
				{
					pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1bce:	88 81       	ld	r24, Y
    1bd0:	99 81       	ldd	r25, Y+1	; 0x01
    1bd2:	9f 83       	std	Y+7, r25	; 0x07
    1bd4:	8e 83       	std	Y+6, r24	; 0x06
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
    1bd6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1bd8:	91 50       	subi	r25, 0x01	; 1
    1bda:	9a 8f       	std	Y+26, r25	; 0x1a
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1bdc:	6e 81       	ldd	r22, Y+6	; 0x06
    1bde:	7f 81       	ldd	r23, Y+7	; 0x07
    1be0:	cf 01       	movw	r24, r30
    1be2:	0e 94 94 12 	call	0x2528	; 0x2528 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1be6:	88 85       	ldd	r24, Y+8	; 0x08
    1be8:	81 11       	cpse	r24, r1
    1bea:	02 c0       	rjmp	.+4      	; 0x1bf0 <xQueueCRReceive+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	09 c0       	rjmp	.+18     	; 0x1c02 <xQueueCRReceive+0x86>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf0:	ce 01       	movw	r24, r28
    1bf2:	08 96       	adiw	r24, 0x08	; 8
    1bf4:	0e 94 95 10 	call	0x212a	; 0x212a <xCoRoutineRemoveFromEventList>
    1bf8:	88 23       	and	r24, r24
    1bfa:	c1 f3       	breq	.-16     	; 0x1bec <xQueueCRReceive+0x70>
					{
						xReturn = errQUEUE_YIELD;
    1bfc:	8b ef       	ldi	r24, 0xFB	; 251
    1bfe:	01 c0       	rjmp	.+2      	; 0x1c02 <xQueueCRReceive+0x86>
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else
			{
				xReturn = pdFAIL;
    1c00:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		portENABLE_INTERRUPTS();
    1c02:	78 94       	sei

		return xReturn;
	}
    1c04:	df 91       	pop	r29
    1c06:	cf 91       	pop	r28
    1c08:	08 95       	ret

00001c0a <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
	{
    1c0a:	0f 93       	push	r16
    1c0c:	1f 93       	push	r17
    1c0e:	cf 93       	push	r28
    1c10:	8c 01       	movw	r16, r24
    1c12:	c4 2f       	mov	r28, r20
	Queue_t * const pxQueue = xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c14:	fc 01       	movw	r30, r24
    1c16:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c18:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c1a:	98 17       	cp	r25, r24
    1c1c:	10 f0       	brcs	.+4      	; 0x1c22 <xQueueCRSendFromISR+0x18>
    1c1e:	4c 2f       	mov	r20, r28
    1c20:	12 c0       	rjmp	.+36     	; 0x1c46 <xQueueCRSendFromISR+0x3c>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1c22:	40 e0       	ldi	r20, 0x00	; 0
    1c24:	c8 01       	movw	r24, r16
    1c26:	0e 94 84 09 	call	0x1308	; 0x1308 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1c2a:	c1 11       	cpse	r28, r1
    1c2c:	f8 cf       	rjmp	.-16     	; 0x1c1e <xQueueCRSendFromISR+0x14>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c2e:	f8 01       	movw	r30, r16
    1c30:	81 89       	ldd	r24, Z+17	; 0x11
    1c32:	88 23       	and	r24, r24
    1c34:	39 f0       	breq	.+14     	; 0x1c44 <xQueueCRSendFromISR+0x3a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c36:	c8 01       	movw	r24, r16
    1c38:	41 96       	adiw	r24, 0x11	; 17
    1c3a:	0e 94 95 10 	call	0x212a	; 0x212a <xCoRoutineRemoveFromEventList>
					{
						return pdTRUE;
    1c3e:	41 e0       	ldi	r20, 0x01	; 1
    1c40:	81 11       	cpse	r24, r1
    1c42:	01 c0       	rjmp	.+2      	; 0x1c46 <xQueueCRSendFromISR+0x3c>
    1c44:	40 e0       	ldi	r20, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xCoRoutinePreviouslyWoken;
	}
    1c46:	84 2f       	mov	r24, r20
    1c48:	cf 91       	pop	r28
    1c4a:	1f 91       	pop	r17
    1c4c:	0f 91       	pop	r16
    1c4e:	08 95       	ret

00001c50 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
	{
    1c50:	0f 93       	push	r16
    1c52:	1f 93       	push	r17
    1c54:	cf 93       	push	r28
    1c56:	df 93       	push	r29
    1c58:	fc 01       	movw	r30, r24
	BaseType_t xReturn;
	Queue_t * const pxQueue = xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1c5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c5c:	88 23       	and	r24, r24
    1c5e:	79 f1       	breq	.+94     	; 0x1cbe <xQueueCRReceiveFromISR+0x6e>
		{
			/* Copy the data from the queue. */
			pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    1c60:	24 8d       	ldd	r18, Z+28	; 0x1c
    1c62:	30 e0       	ldi	r19, 0x00	; 0
    1c64:	a6 81       	ldd	r26, Z+6	; 0x06
    1c66:	b7 81       	ldd	r27, Z+7	; 0x07
    1c68:	a2 0f       	add	r26, r18
    1c6a:	b3 1f       	adc	r27, r19
    1c6c:	b7 83       	std	Z+7, r27	; 0x07
    1c6e:	a6 83       	std	Z+6, r26	; 0x06
			if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    1c70:	84 81       	ldd	r24, Z+4	; 0x04
    1c72:	95 81       	ldd	r25, Z+5	; 0x05
    1c74:	a8 17       	cp	r26, r24
    1c76:	b9 07       	cpc	r27, r25
    1c78:	20 f0       	brcs	.+8      	; 0x1c82 <xQueueCRReceiveFromISR+0x32>
			{
				pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1c7a:	80 81       	ld	r24, Z
    1c7c:	91 81       	ldd	r25, Z+1	; 0x01
    1c7e:	97 83       	std	Z+7, r25	; 0x07
    1c80:	86 83       	std	Z+6, r24	; 0x06
    1c82:	8a 01       	movw	r16, r20
    1c84:	cb 01       	movw	r24, r22
    1c86:	ef 01       	movw	r28, r30
			}
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
			--( pxQueue->uxMessagesWaiting );
    1c88:	42 8d       	ldd	r20, Z+26	; 0x1a
    1c8a:	41 50       	subi	r20, 0x01	; 1
    1c8c:	42 8f       	std	Z+26, r20	; 0x1a
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c8e:	66 81       	ldd	r22, Z+6	; 0x06
    1c90:	77 81       	ldd	r23, Z+7	; 0x07
    1c92:	a9 01       	movw	r20, r18
    1c94:	0e 94 94 12 	call	0x2528	; 0x2528 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    1c98:	f8 01       	movw	r30, r16
    1c9a:	80 81       	ld	r24, Z
    1c9c:	88 23       	and	r24, r24
    1c9e:	11 f0       	breq	.+4      	; 0x1ca4 <xQueueCRReceiveFromISR+0x54>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
    1ca0:	81 e0       	ldi	r24, 0x01	; 1
    1ca2:	0e c0       	rjmp	.+28     	; 0x1cc0 <xQueueCRReceiveFromISR+0x70>
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ca4:	88 85       	ldd	r24, Y+8	; 0x08
    1ca6:	88 23       	and	r24, r24
    1ca8:	d9 f3       	breq	.-10     	; 0x1ca0 <xQueueCRReceiveFromISR+0x50>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1caa:	ce 01       	movw	r24, r28
    1cac:	08 96       	adiw	r24, 0x08	; 8
    1cae:	0e 94 95 10 	call	0x212a	; 0x212a <xCoRoutineRemoveFromEventList>
    1cb2:	88 23       	and	r24, r24
    1cb4:	a9 f3       	breq	.-22     	; 0x1ca0 <xQueueCRReceiveFromISR+0x50>
					{
						*pxCoRoutineWoken = pdTRUE;
    1cb6:	81 e0       	ldi	r24, 0x01	; 1
    1cb8:	f8 01       	movw	r30, r16
    1cba:	80 83       	st	Z, r24
    1cbc:	01 c0       	rjmp	.+2      	; 0x1cc0 <xQueueCRReceiveFromISR+0x70>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
    1cbe:	80 e0       	ldi	r24, 0x00	; 0
		}

		return xReturn;
	}
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
    1cc4:	1f 91       	pop	r17
    1cc6:	0f 91       	pop	r16
    1cc8:	08 95       	ret

00001cca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1cca:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1ccc:	03 96       	adiw	r24, 0x03	; 3
    1cce:	92 83       	std	Z+2, r25	; 0x02
    1cd0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1cd2:	2f ef       	ldi	r18, 0xFF	; 255
    1cd4:	3f ef       	ldi	r19, 0xFF	; 255
    1cd6:	34 83       	std	Z+4, r19	; 0x04
    1cd8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1cda:	96 83       	std	Z+6, r25	; 0x06
    1cdc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1cde:	90 87       	std	Z+8, r25	; 0x08
    1ce0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ce2:	10 82       	st	Z, r1
    1ce4:	08 95       	ret

00001ce6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	11 86       	std	Z+9, r1	; 0x09
    1cea:	10 86       	std	Z+8, r1	; 0x08
    1cec:	08 95       	ret

00001cee <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cee:	cf 93       	push	r28
    1cf0:	df 93       	push	r29
    1cf2:	9c 01       	movw	r18, r24
    1cf4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1cf6:	dc 01       	movw	r26, r24
    1cf8:	11 96       	adiw	r26, 0x01	; 1
    1cfa:	cd 91       	ld	r28, X+
    1cfc:	dc 91       	ld	r29, X
    1cfe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1d00:	d3 83       	std	Z+3, r29	; 0x03
    1d02:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1d04:	8c 81       	ldd	r24, Y+4	; 0x04
    1d06:	9d 81       	ldd	r25, Y+5	; 0x05
    1d08:	95 83       	std	Z+5, r25	; 0x05
    1d0a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1d0c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d0e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d10:	dc 01       	movw	r26, r24
    1d12:	13 96       	adiw	r26, 0x03	; 3
    1d14:	7c 93       	st	X, r23
    1d16:	6e 93       	st	-X, r22
    1d18:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1d1a:	7d 83       	std	Y+5, r23	; 0x05
    1d1c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    1d1e:	31 87       	std	Z+9, r19	; 0x09
    1d20:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1d22:	f9 01       	movw	r30, r18
    1d24:	80 81       	ld	r24, Z
    1d26:	8f 5f       	subi	r24, 0xFF	; 255
    1d28:	80 83       	st	Z, r24
}
    1d2a:	df 91       	pop	r29
    1d2c:	cf 91       	pop	r28
    1d2e:	08 95       	ret

00001d30 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1d30:	0f 93       	push	r16
    1d32:	1f 93       	push	r17
    1d34:	cf 93       	push	r28
    1d36:	df 93       	push	r29
    1d38:	8c 01       	movw	r16, r24
    1d3a:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1d3c:	80 81       	ld	r24, Z
    1d3e:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1d40:	8f 3f       	cpi	r24, 0xFF	; 255
    1d42:	2f ef       	ldi	r18, 0xFF	; 255
    1d44:	92 07       	cpc	r25, r18
    1d46:	21 f4       	brne	.+8      	; 0x1d50 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d48:	e8 01       	movw	r28, r16
    1d4a:	af 81       	ldd	r26, Y+7	; 0x07
    1d4c:	b8 85       	ldd	r27, Y+8	; 0x08
    1d4e:	0e c0       	rjmp	.+28     	; 0x1d6c <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1d50:	d8 01       	movw	r26, r16
    1d52:	13 96       	adiw	r26, 0x03	; 3
    1d54:	12 96       	adiw	r26, 0x02	; 2
    1d56:	2d 91       	ld	r18, X+
    1d58:	3c 91       	ld	r19, X
    1d5a:	13 97       	sbiw	r26, 0x03	; 3
    1d5c:	e9 01       	movw	r28, r18
    1d5e:	48 81       	ld	r20, Y
    1d60:	59 81       	ldd	r21, Y+1	; 0x01
    1d62:	84 17       	cp	r24, r20
    1d64:	95 07       	cpc	r25, r21
    1d66:	10 f0       	brcs	.+4      	; 0x1d6c <vListInsert+0x3c>
    1d68:	d9 01       	movw	r26, r18
    1d6a:	f4 cf       	rjmp	.-24     	; 0x1d54 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d6c:	12 96       	adiw	r26, 0x02	; 2
    1d6e:	8d 91       	ld	r24, X+
    1d70:	9c 91       	ld	r25, X
    1d72:	13 97       	sbiw	r26, 0x03	; 3
    1d74:	93 83       	std	Z+3, r25	; 0x03
    1d76:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d78:	ec 01       	movw	r28, r24
    1d7a:	fd 83       	std	Y+5, r31	; 0x05
    1d7c:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1d7e:	b5 83       	std	Z+5, r27	; 0x05
    1d80:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1d82:	13 96       	adiw	r26, 0x03	; 3
    1d84:	fc 93       	st	X, r31
    1d86:	ee 93       	st	-X, r30
    1d88:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    1d8a:	11 87       	std	Z+9, r17	; 0x09
    1d8c:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    1d8e:	f8 01       	movw	r30, r16
    1d90:	80 81       	ld	r24, Z
    1d92:	8f 5f       	subi	r24, 0xFF	; 255
    1d94:	80 83       	st	Z, r24
}
    1d96:	df 91       	pop	r29
    1d98:	cf 91       	pop	r28
    1d9a:	1f 91       	pop	r17
    1d9c:	0f 91       	pop	r16
    1d9e:	08 95       	ret

00001da0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
    1da4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1da6:	a0 85       	ldd	r26, Z+8	; 0x08
    1da8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1daa:	82 81       	ldd	r24, Z+2	; 0x02
    1dac:	93 81       	ldd	r25, Z+3	; 0x03
    1dae:	24 81       	ldd	r18, Z+4	; 0x04
    1db0:	35 81       	ldd	r19, Z+5	; 0x05
    1db2:	ec 01       	movw	r28, r24
    1db4:	3d 83       	std	Y+5, r19	; 0x05
    1db6:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1db8:	c4 81       	ldd	r28, Z+4	; 0x04
    1dba:	d5 81       	ldd	r29, Z+5	; 0x05
    1dbc:	9b 83       	std	Y+3, r25	; 0x03
    1dbe:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1dc0:	11 96       	adiw	r26, 0x01	; 1
    1dc2:	8d 91       	ld	r24, X+
    1dc4:	9c 91       	ld	r25, X
    1dc6:	12 97       	sbiw	r26, 0x02	; 2
    1dc8:	e8 17       	cp	r30, r24
    1dca:	f9 07       	cpc	r31, r25
    1dcc:	21 f4       	brne	.+8      	; 0x1dd6 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1dce:	12 96       	adiw	r26, 0x02	; 2
    1dd0:	dc 93       	st	X, r29
    1dd2:	ce 93       	st	-X, r28
    1dd4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1dd6:	11 86       	std	Z+9, r1	; 0x09
    1dd8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1dda:	8c 91       	ld	r24, X
    1ddc:	81 50       	subi	r24, 0x01	; 1
    1dde:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1de0:	8c 91       	ld	r24, X
}
    1de2:	df 91       	pop	r29
    1de4:	cf 91       	pop	r28
    1de6:	08 95       	ret

00001de8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
{
    1de8:	cf 92       	push	r12
    1dea:	df 92       	push	r13
    1dec:	ef 92       	push	r14
    1dee:	ff 92       	push	r15
    1df0:	1f 93       	push	r17
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	6c 01       	movw	r12, r24
    1df8:	16 2f       	mov	r17, r22
    1dfa:	f4 2e       	mov	r15, r20
BaseType_t xReturn;
CRCB_t *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
    1dfc:	8a e1       	ldi	r24, 0x1A	; 26
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	0e 94 ba 10 	call	0x2174	; 0x2174 <pvPortMalloc>
    1e04:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1e06:	89 2b       	or	r24, r25
    1e08:	09 f4       	brne	.+2      	; 0x1e0c <xCoRoutineCreate+0x24>
    1e0a:	57 c0       	rjmp	.+174    	; 0x1eba <xCoRoutineCreate+0xd2>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1e0c:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1e10:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1e14:	89 2b       	or	r24, r25
    1e16:	21 f5       	brne	.+72     	; 0x1e60 <xCoRoutineCreate+0x78>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1e18:	d0 93 a5 01 	sts	0x01A5, r29	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1e1c:	c0 93 a4 01 	sts	0x01A4, r28	; 0x8001a4 <pxCurrentCoRoutine>
{
UBaseType_t uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1e20:	8c ec       	ldi	r24, 0xCC	; 204
    1e22:	91 e0       	ldi	r25, 0x01	; 1
    1e24:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
    1e28:	85 ed       	ldi	r24, 0xD5	; 213
    1e2a:	91 e0       	ldi	r25, 0x01	; 1
    1e2c:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	}

	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    1e30:	83 ec       	ldi	r24, 0xC3	; 195
    1e32:	91 e0       	ldi	r25, 0x01	; 1
    1e34:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1e38:	8a eb       	ldi	r24, 0xBA	; 186
    1e3a:	91 e0       	ldi	r25, 0x01	; 1
    1e3c:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>
	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    1e40:	8d ea       	ldi	r24, 0xAD	; 173
    1e42:	91 e0       	ldi	r25, 0x01	; 1
    1e44:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1e48:	83 ec       	ldi	r24, 0xC3	; 195
    1e4a:	91 e0       	ldi	r25, 0x01	; 1
    1e4c:	90 93 b9 01 	sts	0x01B9, r25	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1e50:	80 93 b8 01 	sts	0x01B8, r24	; 0x8001b8 <pxDelayedCoRoutineList>
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1e54:	8a eb       	ldi	r24, 0xBA	; 186
    1e56:	91 e0       	ldi	r25, 0x01	; 1
    1e58:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1e5c:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1e60:	11 11       	cpse	r17, r1
    1e62:	11 e0       	ldi	r17, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1e64:	19 8e       	std	Y+25, r1	; 0x19
    1e66:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1e68:	1e 8b       	std	Y+22, r17	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1e6a:	ff 8a       	std	Y+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1e6c:	fe 01       	movw	r30, r28
    1e6e:	c1 92       	st	Z+, r12
    1e70:	d1 92       	st	Z+, r13
    1e72:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1e74:	cf 01       	movw	r24, r30
    1e76:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1e7a:	ce 01       	movw	r24, r28
    1e7c:	0c 96       	adiw	r24, 0x0c	; 12
    1e7e:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the ListItem_t.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1e82:	d9 87       	std	Y+9, r29	; 0x09
    1e84:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1e86:	db 8b       	std	Y+19, r29	; 0x13
    1e88:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
    1e8a:	82 e0       	ldi	r24, 0x02	; 2
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	81 1b       	sub	r24, r17
    1e90:	91 09       	sbc	r25, r1
    1e92:	9d 87       	std	Y+13, r25	; 0x0d
    1e94:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e96:	8e 89       	ldd	r24, Y+22	; 0x16
    1e98:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1e9c:	98 17       	cp	r25, r24
    1e9e:	10 f4       	brcc	.+4      	; 0x1ea4 <xCoRoutineCreate+0xbc>
    1ea0:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1ea4:	f9 e0       	ldi	r31, 0x09	; 9
    1ea6:	8f 9f       	mul	r24, r31
    1ea8:	c0 01       	movw	r24, r0
    1eaa:	11 24       	eor	r1, r1
    1eac:	b7 01       	movw	r22, r14
    1eae:	84 53       	subi	r24, 0x34	; 52
    1eb0:	9e 4f       	sbci	r25, 0xFE	; 254
    1eb2:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

		xReturn = pdPASS;
    1eb6:	81 e0       	ldi	r24, 0x01	; 1
    1eb8:	01 c0       	rjmp	.+2      	; 0x1ebc <xCoRoutineCreate+0xd4>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1eba:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    1ebc:	df 91       	pop	r29
    1ebe:	cf 91       	pop	r28
    1ec0:	1f 91       	pop	r17
    1ec2:	ff 90       	pop	r15
    1ec4:	ef 90       	pop	r14
    1ec6:	df 90       	pop	r13
    1ec8:	cf 90       	pop	r12
    1eca:	08 95       	ret

00001ecc <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
{
    1ecc:	0f 93       	push	r16
    1ece:	1f 93       	push	r17
    1ed0:	cf 93       	push	r28
    1ed2:	df 93       	push	r29
    1ed4:	8b 01       	movw	r16, r22
TickType_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1ed6:	c0 91 aa 01 	lds	r28, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1eda:	d0 91 ab 01 	lds	r29, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1ede:	c8 0f       	add	r28, r24
    1ee0:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ee2:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1ee6:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1eea:	02 96       	adiw	r24, 0x02	; 2
    1eec:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1ef0:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1ef4:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1ef8:	d3 83       	std	Z+3, r29	; 0x03
    1efa:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1efc:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1f00:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1f04:	bf 01       	movw	r22, r30
    1f06:	6e 5f       	subi	r22, 0xFE	; 254
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0a:	c8 17       	cp	r28, r24
    1f0c:	d9 07       	cpc	r29, r25
    1f0e:	28 f4       	brcc	.+10     	; 0x1f1a <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f10:	80 91 b6 01 	lds	r24, 0x01B6	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    1f14:	90 91 b7 01 	lds	r25, 0x01B7	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    1f18:	04 c0       	rjmp	.+8      	; 0x1f22 <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1f1a:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    1f1e:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    1f22:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <vListInsert>
	}

	if( pxEventList )
    1f26:	01 15       	cp	r16, r1
    1f28:	11 05       	cpc	r17, r1
    1f2a:	69 f0       	breq	.+26     	; 0x1f46 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1f2c:	60 91 a4 01 	lds	r22, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    1f30:	70 91 a5 01 	lds	r23, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    1f34:	64 5f       	subi	r22, 0xF4	; 244
    1f36:	7f 4f       	sbci	r23, 0xFF	; 255
    1f38:	c8 01       	movw	r24, r16
	}
}
    1f3a:	df 91       	pop	r29
    1f3c:	cf 91       	pop	r28
    1f3e:	1f 91       	pop	r17
    1f40:	0f 91       	pop	r16

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1f42:	0c 94 98 0e 	jmp	0x1d30	; 0x1d30 <vListInsert>
	}
}
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	08 95       	ret

00001f50 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1f50:	ff 92       	push	r15
    1f52:	0f 93       	push	r16
    1f54:	1f 93       	push	r17
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f5a:	99 e0       	ldi	r25, 0x09	; 9
    1f5c:	f9 2e       	mov	r15, r25
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1f5e:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <xPendingReadyCoRoutineList>
    1f62:	88 23       	and	r24, r24
    1f64:	11 f1       	breq	.+68     	; 0x1faa <vCoRoutineSchedule+0x5a>
	{
		CRCB_t *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1f66:	f8 94       	cli
		{
			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1f68:	e0 91 b2 01 	lds	r30, 0x01B2	; 0x8001b2 <xPendingReadyCoRoutineList+0x5>
    1f6c:	f0 91 b3 01 	lds	r31, 0x01B3	; 0x8001b3 <xPendingReadyCoRoutineList+0x6>
    1f70:	c6 81       	ldd	r28, Z+6	; 0x06
    1f72:	d7 81       	ldd	r29, Z+7	; 0x07
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f74:	ce 01       	movw	r24, r28
    1f76:	0c 96       	adiw	r24, 0x0c	; 12
    1f78:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1f7c:	78 94       	sei

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f7e:	8e 01       	movw	r16, r28
    1f80:	0e 5f       	subi	r16, 0xFE	; 254
    1f82:	1f 4f       	sbci	r17, 0xFF	; 255
    1f84:	c8 01       	movw	r24, r16
    1f86:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1f8a:	8e 89       	ldd	r24, Y+22	; 0x16
    1f8c:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1f90:	98 17       	cp	r25, r24
    1f92:	10 f4       	brcc	.+4      	; 0x1f98 <vCoRoutineSchedule+0x48>
    1f94:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    1f98:	f8 9e       	mul	r15, r24
    1f9a:	c0 01       	movw	r24, r0
    1f9c:	11 24       	eor	r1, r1
    1f9e:	b8 01       	movw	r22, r16
    1fa0:	84 53       	subi	r24, 0x34	; 52
    1fa2:	9e 4f       	sbci	r25, 0xFE	; 254
    1fa4:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
    1fa8:	da cf       	rjmp	.-76     	; 0x1f5e <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1faa:	0e 94 33 04 	call	0x866	; 0x866 <xTaskGetTickCount>
    1fae:	20 91 a8 01 	lds	r18, 0x01A8	; 0x8001a8 <xLastTickCount>
    1fb2:	30 91 a9 01 	lds	r19, 0x01A9	; 0x8001a9 <xLastTickCount+0x1>
    1fb6:	82 1b       	sub	r24, r18
    1fb8:	93 0b       	sbc	r25, r19
    1fba:	90 93 a7 01 	sts	0x01A7, r25	; 0x8001a7 <xPassedTicks+0x1>
    1fbe:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <xPassedTicks>
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1fc2:	89 e0       	ldi	r24, 0x09	; 9
    1fc4:	f8 2e       	mov	r15, r24
static void prvCheckDelayedList( void )
{
CRCB_t *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1fc6:	20 91 a6 01 	lds	r18, 0x01A6	; 0x8001a6 <xPassedTicks>
    1fca:	30 91 a7 01 	lds	r19, 0x01A7	; 0x8001a7 <xPassedTicks+0x1>
    1fce:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    1fd2:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    1fd6:	21 15       	cp	r18, r1
    1fd8:	31 05       	cpc	r19, r1
    1fda:	09 f4       	brne	.+2      	; 0x1fde <vCoRoutineSchedule+0x8e>
    1fdc:	54 c0       	rjmp	.+168    	; 0x2086 <vCoRoutineSchedule+0x136>
	{
		xCoRoutineTickCount++;
    1fde:	01 96       	adiw	r24, 0x01	; 1
    1fe0:	90 93 ab 01 	sts	0x01AB, r25	; 0x8001ab <xCoRoutineTickCount+0x1>
    1fe4:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <xCoRoutineTickCount>
		xPassedTicks--;
    1fe8:	21 50       	subi	r18, 0x01	; 1
    1fea:	31 09       	sbc	r19, r1
    1fec:	30 93 a7 01 	sts	0x01A7, r19	; 0x8001a7 <xPassedTicks+0x1>
    1ff0:	20 93 a6 01 	sts	0x01A6, r18	; 0x8001a6 <xPassedTicks>

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1ff4:	89 2b       	or	r24, r25
    1ff6:	09 f0       	breq	.+2      	; 0x1ffa <vCoRoutineSchedule+0xaa>
    1ff8:	3e c0       	rjmp	.+124    	; 0x2076 <vCoRoutineSchedule+0x126>
		{
			List_t * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1ffa:	80 91 b8 01 	lds	r24, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    1ffe:	90 91 b9 01 	lds	r25, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2002:	20 91 b6 01 	lds	r18, 0x01B6	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    2006:	30 91 b7 01 	lds	r19, 0x01B7	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    200a:	30 93 b9 01 	sts	0x01B9, r19	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    200e:	20 93 b8 01 	sts	0x01B8, r18	; 0x8001b8 <pxDelayedCoRoutineList>
			pxOverflowDelayedCoRoutineList = pxTemp;
    2012:	90 93 b7 01 	sts	0x01B7, r25	; 0x8001b7 <pxOverflowDelayedCoRoutineList+0x1>
    2016:	80 93 b6 01 	sts	0x01B6, r24	; 0x8001b6 <pxOverflowDelayedCoRoutineList>
    201a:	2d c0       	rjmp	.+90     	; 0x2076 <vCoRoutineSchedule+0x126>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    201c:	05 80       	ldd	r0, Z+5	; 0x05
    201e:	f6 81       	ldd	r31, Z+6	; 0x06
    2020:	e0 2d       	mov	r30, r0
    2022:	c6 81       	ldd	r28, Z+6	; 0x06
    2024:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2026:	2a 81       	ldd	r18, Y+2	; 0x02
    2028:	3b 81       	ldd	r19, Y+3	; 0x03
    202a:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <xCoRoutineTickCount>
    202e:	90 91 ab 01 	lds	r25, 0x01AB	; 0x8001ab <xCoRoutineTickCount+0x1>
    2032:	82 17       	cp	r24, r18
    2034:	93 07       	cpc	r25, r19
    2036:	38 f2       	brcs	.-114    	; 0x1fc6 <vCoRoutineSchedule+0x76>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2038:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    203a:	8e 01       	movw	r16, r28
    203c:	0e 5f       	subi	r16, 0xFE	; 254
    203e:	1f 4f       	sbci	r17, 0xFF	; 255
    2040:	c8 01       	movw	r24, r16
    2042:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pxContainer )
    2046:	8c 89       	ldd	r24, Y+20	; 0x14
    2048:	9d 89       	ldd	r25, Y+21	; 0x15
    204a:	89 2b       	or	r24, r25
    204c:	21 f0       	breq	.+8      	; 0x2056 <vCoRoutineSchedule+0x106>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    204e:	ce 01       	movw	r24, r28
    2050:	0c 96       	adiw	r24, 0x0c	; 12
    2052:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2056:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2058:	8e 89       	ldd	r24, Y+22	; 0x16
    205a:	90 91 ac 01 	lds	r25, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>
    205e:	98 17       	cp	r25, r24
    2060:	10 f4       	brcc	.+4      	; 0x2066 <vCoRoutineSchedule+0x116>
    2062:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
    2066:	f8 9e       	mul	r15, r24
    2068:	c0 01       	movw	r24, r0
    206a:	11 24       	eor	r1, r1
    206c:	b8 01       	movw	r22, r16
    206e:	84 53       	subi	r24, 0x34	; 52
    2070:	9e 4f       	sbci	r25, 0xFE	; 254
    2072:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2076:	e0 91 b8 01 	lds	r30, 0x01B8	; 0x8001b8 <pxDelayedCoRoutineList>
    207a:	f0 91 b9 01 	lds	r31, 0x01B9	; 0x8001b9 <pxDelayedCoRoutineList+0x1>
    207e:	80 81       	ld	r24, Z
    2080:	81 11       	cpse	r24, r1
    2082:	cc cf       	rjmp	.-104    	; 0x201c <vCoRoutineSchedule+0xcc>
    2084:	a0 cf       	rjmp	.-192    	; 0x1fc6 <vCoRoutineSchedule+0x76>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2086:	90 93 a9 01 	sts	0x01A9, r25	; 0x8001a9 <xLastTickCount+0x1>
    208a:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <xLastTickCount>
    208e:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <uxTopCoRoutineReadyPriority>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2092:	69 e0       	ldi	r22, 0x09	; 9
    2094:	48 2f       	mov	r20, r24
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	64 9f       	mul	r22, r20
    209a:	90 01       	movw	r18, r0
    209c:	65 9f       	mul	r22, r21
    209e:	30 0d       	add	r19, r0
    20a0:	11 24       	eor	r1, r1
    20a2:	f9 01       	movw	r30, r18
    20a4:	e4 53       	subi	r30, 0x34	; 52
    20a6:	fe 4f       	sbci	r31, 0xFE	; 254
    20a8:	90 81       	ld	r25, Z
    20aa:	91 11       	cpse	r25, r1
    20ac:	0c c0       	rjmp	.+24     	; 0x20c6 <vCoRoutineSchedule+0x176>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    20ae:	81 11       	cpse	r24, r1
    20b0:	08 c0       	rjmp	.+16     	; 0x20c2 <vCoRoutineSchedule+0x172>
    20b2:	10 92 ac 01 	sts	0x01AC, r1	; 0x8001ac <uxTopCoRoutineReadyPriority>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    20b6:	df 91       	pop	r29
    20b8:	cf 91       	pop	r28
    20ba:	1f 91       	pop	r17
    20bc:	0f 91       	pop	r16
    20be:	ff 90       	pop	r15
    20c0:	08 95       	ret
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    20c2:	81 50       	subi	r24, 0x01	; 1
    20c4:	e7 cf       	rjmp	.-50     	; 0x2094 <vCoRoutineSchedule+0x144>
    20c6:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <uxTopCoRoutineReadyPriority>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    20ca:	a1 81       	ldd	r26, Z+1	; 0x01
    20cc:	b2 81       	ldd	r27, Z+2	; 0x02
    20ce:	12 96       	adiw	r26, 0x02	; 2
    20d0:	0d 90       	ld	r0, X+
    20d2:	bc 91       	ld	r27, X
    20d4:	a0 2d       	mov	r26, r0
    20d6:	b2 83       	std	Z+2, r27	; 0x02
    20d8:	a1 83       	std	Z+1, r26	; 0x01
    20da:	21 53       	subi	r18, 0x31	; 49
    20dc:	3e 4f       	sbci	r19, 0xFE	; 254
    20de:	a2 17       	cp	r26, r18
    20e0:	b3 07       	cpc	r27, r19
    20e2:	31 f4       	brne	.+12     	; 0x20f0 <vCoRoutineSchedule+0x1a0>
    20e4:	12 96       	adiw	r26, 0x02	; 2
    20e6:	8d 91       	ld	r24, X+
    20e8:	9c 91       	ld	r25, X
    20ea:	13 97       	sbiw	r26, 0x03	; 3
    20ec:	92 83       	std	Z+2, r25	; 0x02
    20ee:	81 83       	std	Z+1, r24	; 0x01
    20f0:	89 e0       	ldi	r24, 0x09	; 9
    20f2:	84 9f       	mul	r24, r20
    20f4:	f0 01       	movw	r30, r0
    20f6:	85 9f       	mul	r24, r21
    20f8:	f0 0d       	add	r31, r0
    20fa:	11 24       	eor	r1, r1
    20fc:	e4 53       	subi	r30, 0x34	; 52
    20fe:	fe 4f       	sbci	r31, 0xFE	; 254
    2100:	01 80       	ldd	r0, Z+1	; 0x01
    2102:	f2 81       	ldd	r31, Z+2	; 0x02
    2104:	e0 2d       	mov	r30, r0
    2106:	86 81       	ldd	r24, Z+6	; 0x06
    2108:	97 81       	ldd	r25, Z+7	; 0x07
    210a:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <pxCurrentCoRoutine+0x1>
    210e:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <pxCurrentCoRoutine>

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2112:	dc 01       	movw	r26, r24
    2114:	ed 91       	ld	r30, X+
    2116:	fc 91       	ld	r31, X
    2118:	11 97       	sbiw	r26, 0x01	; 1
    211a:	57 96       	adiw	r26, 0x17	; 23
    211c:	6c 91       	ld	r22, X

	return;
}
    211e:	df 91       	pop	r29
    2120:	cf 91       	pop	r28
    2122:	1f 91       	pop	r17
    2124:	0f 91       	pop	r16
    2126:	ff 90       	pop	r15
	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2128:	09 94       	ijmp

0000212a <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
{
    212a:	0f 93       	push	r16
    212c:	1f 93       	push	r17
    212e:	cf 93       	push	r28
    2130:	df 93       	push	r29
BaseType_t xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2132:	dc 01       	movw	r26, r24
    2134:	15 96       	adiw	r26, 0x05	; 5
    2136:	ed 91       	ld	r30, X+
    2138:	fc 91       	ld	r31, X
    213a:	16 97       	sbiw	r26, 0x06	; 6
    213c:	c6 81       	ldd	r28, Z+6	; 0x06
    213e:	d7 81       	ldd	r29, Z+7	; 0x07
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2140:	8e 01       	movw	r16, r28
    2142:	04 5f       	subi	r16, 0xF4	; 244
    2144:	1f 4f       	sbci	r17, 0xFF	; 255
    2146:	c8 01       	movw	r24, r16
    2148:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <uxListRemove>
	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    214c:	b8 01       	movw	r22, r16
    214e:	8d ea       	ldi	r24, 0xAD	; 173
    2150:	91 e0       	ldi	r25, 0x01	; 1
    2152:	0e 94 77 0e 	call	0x1cee	; 0x1cee <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2156:	e0 91 a4 01 	lds	r30, 0x01A4	; 0x8001a4 <pxCurrentCoRoutine>
    215a:	f0 91 a5 01 	lds	r31, 0x01A5	; 0x8001a5 <pxCurrentCoRoutine+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    215e:	81 e0       	ldi	r24, 0x01	; 1
    2160:	2e 89       	ldd	r18, Y+22	; 0x16
    2162:	96 89       	ldd	r25, Z+22	; 0x16
    2164:	29 17       	cp	r18, r25
    2166:	08 f4       	brcc	.+2      	; 0x216a <xCoRoutineRemoveFromEventList+0x40>
    2168:	80 e0       	ldi	r24, 0x00	; 0
}
    216a:	df 91       	pop	r29
    216c:	cf 91       	pop	r28
    216e:	1f 91       	pop	r17
    2170:	0f 91       	pop	r16
    2172:	08 95       	ret

00002174 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2174:	cf 93       	push	r28
    2176:	df 93       	push	r29
    2178:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    217a:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    217e:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <pucAlignedHeap.2081>
    2182:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <pucAlignedHeap.2081+0x1>
    2186:	89 2b       	or	r24, r25
    2188:	31 f4       	brne	.+12     	; 0x2196 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    218a:	83 ee       	ldi	r24, 0xE3	; 227
    218c:	91 e0       	ldi	r25, 0x01	; 1
    218e:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <pucAlignedHeap.2081+0x1>
    2192:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <pucAlignedHeap.2081>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2196:	20 91 e0 01 	lds	r18, 0x01E0	; 0x8001e0 <xNextFreeByte>
    219a:	30 91 e1 01 	lds	r19, 0x01E1	; 0x8001e1 <xNextFreeByte+0x1>
    219e:	c9 01       	movw	r24, r18
    21a0:	8c 0f       	add	r24, r28
    21a2:	9d 1f       	adc	r25, r29
    21a4:	8b 3d       	cpi	r24, 0xDB	; 219
    21a6:	45 e0       	ldi	r20, 0x05	; 5
    21a8:	94 07       	cpc	r25, r20
    21aa:	70 f4       	brcc	.+28     	; 0x21c8 <pvPortMalloc+0x54>
    21ac:	28 17       	cp	r18, r24
    21ae:	39 07       	cpc	r19, r25
    21b0:	58 f4       	brcc	.+22     	; 0x21c8 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    21b2:	c0 91 de 01 	lds	r28, 0x01DE	; 0x8001de <pucAlignedHeap.2081>
    21b6:	d0 91 df 01 	lds	r29, 0x01DF	; 0x8001df <pucAlignedHeap.2081+0x1>
    21ba:	c2 0f       	add	r28, r18
    21bc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    21be:	90 93 e1 01 	sts	0x01E1, r25	; 0x8001e1 <xNextFreeByte+0x1>
    21c2:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <xNextFreeByte>
    21c6:	02 c0       	rjmp	.+4      	; 0x21cc <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    21c8:	c0 e0       	ldi	r28, 0x00	; 0
    21ca:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    21cc:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    21d0:	ce 01       	movw	r24, r28
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	08 95       	ret

000021d8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    21d8:	08 95       	ret

000021da <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    21da:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <xNextFreeByte+0x1>
    21de:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <xNextFreeByte>
    21e2:	08 95       	ret

000021e4 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    21e4:	20 91 e0 01 	lds	r18, 0x01E0	; 0x8001e0 <xNextFreeByte>
    21e8:	30 91 e1 01 	lds	r19, 0x01E1	; 0x8001e1 <xNextFreeByte+0x1>
}
    21ec:	8b ed       	ldi	r24, 0xDB	; 219
    21ee:	95 e0       	ldi	r25, 0x05	; 5
    21f0:	82 1b       	sub	r24, r18
    21f2:	93 0b       	sbc	r25, r19
    21f4:	08 95       	ret

000021f6 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    21f6:	31 e1       	ldi	r19, 0x11	; 17
    21f8:	fc 01       	movw	r30, r24
    21fa:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    21fc:	31 97       	sbiw	r30, 0x01	; 1
    21fe:	22 e2       	ldi	r18, 0x22	; 34
    2200:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    2202:	31 97       	sbiw	r30, 0x01	; 1
    2204:	a3 e3       	ldi	r26, 0x33	; 51
    2206:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    2208:	31 97       	sbiw	r30, 0x01	; 1
    220a:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    220c:	31 97       	sbiw	r30, 0x01	; 1
    220e:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    2210:	31 97       	sbiw	r30, 0x01	; 1
    2212:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2214:	31 97       	sbiw	r30, 0x01	; 1
    2216:	60 e8       	ldi	r22, 0x80	; 128
    2218:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    221a:	31 97       	sbiw	r30, 0x01	; 1
    221c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    221e:	31 97       	sbiw	r30, 0x01	; 1
    2220:	62 e0       	ldi	r22, 0x02	; 2
    2222:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    2224:	31 97       	sbiw	r30, 0x01	; 1
    2226:	63 e0       	ldi	r22, 0x03	; 3
    2228:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    222a:	31 97       	sbiw	r30, 0x01	; 1
    222c:	64 e0       	ldi	r22, 0x04	; 4
    222e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    2230:	31 97       	sbiw	r30, 0x01	; 1
    2232:	65 e0       	ldi	r22, 0x05	; 5
    2234:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	66 e0       	ldi	r22, 0x06	; 6
    223a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    223c:	31 97       	sbiw	r30, 0x01	; 1
    223e:	67 e0       	ldi	r22, 0x07	; 7
    2240:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    2242:	31 97       	sbiw	r30, 0x01	; 1
    2244:	68 e0       	ldi	r22, 0x08	; 8
    2246:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    2248:	31 97       	sbiw	r30, 0x01	; 1
    224a:	69 e0       	ldi	r22, 0x09	; 9
    224c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    224e:	31 97       	sbiw	r30, 0x01	; 1
    2250:	60 e1       	ldi	r22, 0x10	; 16
    2252:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    2254:	31 97       	sbiw	r30, 0x01	; 1
    2256:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    2258:	31 97       	sbiw	r30, 0x01	; 1
    225a:	32 e1       	ldi	r19, 0x12	; 18
    225c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    225e:	31 97       	sbiw	r30, 0x01	; 1
    2260:	33 e1       	ldi	r19, 0x13	; 19
    2262:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    2264:	31 97       	sbiw	r30, 0x01	; 1
    2266:	34 e1       	ldi	r19, 0x14	; 20
    2268:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    226a:	31 97       	sbiw	r30, 0x01	; 1
    226c:	35 e1       	ldi	r19, 0x15	; 21
    226e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    2270:	31 97       	sbiw	r30, 0x01	; 1
    2272:	36 e1       	ldi	r19, 0x16	; 22
    2274:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    2276:	31 97       	sbiw	r30, 0x01	; 1
    2278:	37 e1       	ldi	r19, 0x17	; 23
    227a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    227c:	31 97       	sbiw	r30, 0x01	; 1
    227e:	38 e1       	ldi	r19, 0x18	; 24
    2280:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    2282:	31 97       	sbiw	r30, 0x01	; 1
    2284:	39 e1       	ldi	r19, 0x19	; 25
    2286:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    2288:	31 97       	sbiw	r30, 0x01	; 1
    228a:	30 e2       	ldi	r19, 0x20	; 32
    228c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    228e:	31 97       	sbiw	r30, 0x01	; 1
    2290:	31 e2       	ldi	r19, 0x21	; 33
    2292:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    2294:	31 97       	sbiw	r30, 0x01	; 1
    2296:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    2298:	31 97       	sbiw	r30, 0x01	; 1
    229a:	23 e2       	ldi	r18, 0x23	; 35
    229c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    229e:	31 97       	sbiw	r30, 0x01	; 1
    22a0:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    22a2:	31 97       	sbiw	r30, 0x01	; 1
    22a4:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    22a6:	31 97       	sbiw	r30, 0x01	; 1
    22a8:	26 e2       	ldi	r18, 0x26	; 38
    22aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    22ac:	31 97       	sbiw	r30, 0x01	; 1
    22ae:	27 e2       	ldi	r18, 0x27	; 39
    22b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    22b2:	31 97       	sbiw	r30, 0x01	; 1
    22b4:	28 e2       	ldi	r18, 0x28	; 40
    22b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    22b8:	31 97       	sbiw	r30, 0x01	; 1
    22ba:	29 e2       	ldi	r18, 0x29	; 41
    22bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    22be:	31 97       	sbiw	r30, 0x01	; 1
    22c0:	20 e3       	ldi	r18, 0x30	; 48
    22c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    22c4:	31 97       	sbiw	r30, 0x01	; 1
    22c6:	21 e3       	ldi	r18, 0x31	; 49
    22c8:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    22ca:	86 97       	sbiw	r24, 0x26	; 38
    22cc:	08 95       	ret

000022ce <xPortStartScheduler>:
	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
OCR1A = ulCompareMatch;
    22ce:	89 ef       	ldi	r24, 0xF9	; 249
    22d0:	90 e0       	ldi	r25, 0x00	; 0
    22d2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    22d6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

	/* Setup clock source and compare match behaviour. */
	TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));;
    22da:	e0 e8       	ldi	r30, 0x80	; 128
    22dc:	f0 e0       	ldi	r31, 0x00	; 0
    22de:	80 81       	ld	r24, Z
    22e0:	8c 7f       	andi	r24, 0xFC	; 252
    22e2:	80 83       	st	Z, r24
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    22e4:	8b e0       	ldi	r24, 0x0B	; 11
    22e6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
    22ea:	ef e6       	ldi	r30, 0x6F	; 111
    22ec:	f0 e0       	ldi	r31, 0x00	; 0
    22ee:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    22f0:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
    22f2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    22f4:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    22f8:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    22fc:	cd 91       	ld	r28, X+
    22fe:	cd bf       	out	0x3d, r28	; 61
    2300:	dd 91       	ld	r29, X+
    2302:	de bf       	out	0x3e, r29	; 62
    2304:	ff 91       	pop	r31
    2306:	ef 91       	pop	r30
    2308:	df 91       	pop	r29
    230a:	cf 91       	pop	r28
    230c:	bf 91       	pop	r27
    230e:	af 91       	pop	r26
    2310:	9f 91       	pop	r25
    2312:	8f 91       	pop	r24
    2314:	7f 91       	pop	r23
    2316:	6f 91       	pop	r22
    2318:	5f 91       	pop	r21
    231a:	4f 91       	pop	r20
    231c:	3f 91       	pop	r19
    231e:	2f 91       	pop	r18
    2320:	1f 91       	pop	r17
    2322:	0f 91       	pop	r16
    2324:	ff 90       	pop	r15
    2326:	ef 90       	pop	r14
    2328:	df 90       	pop	r13
    232a:	cf 90       	pop	r12
    232c:	bf 90       	pop	r11
    232e:	af 90       	pop	r10
    2330:	9f 90       	pop	r9
    2332:	8f 90       	pop	r8
    2334:	7f 90       	pop	r7
    2336:	6f 90       	pop	r6
    2338:	5f 90       	pop	r5
    233a:	4f 90       	pop	r4
    233c:	3f 90       	pop	r3
    233e:	2f 90       	pop	r2
    2340:	1f 90       	pop	r1
    2342:	0f 90       	pop	r0
    2344:	0f be       	out	0x3f, r0	; 63
    2346:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2348:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    234a:	81 e0       	ldi	r24, 0x01	; 1
    234c:	08 95       	ret

0000234e <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    234e:	08 95       	ret

00002350 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2350:	0f 92       	push	r0
    2352:	0f b6       	in	r0, 0x3f	; 63
    2354:	f8 94       	cli
    2356:	0f 92       	push	r0
    2358:	1f 92       	push	r1
    235a:	11 24       	eor	r1, r1
    235c:	2f 92       	push	r2
    235e:	3f 92       	push	r3
    2360:	4f 92       	push	r4
    2362:	5f 92       	push	r5
    2364:	6f 92       	push	r6
    2366:	7f 92       	push	r7
    2368:	8f 92       	push	r8
    236a:	9f 92       	push	r9
    236c:	af 92       	push	r10
    236e:	bf 92       	push	r11
    2370:	cf 92       	push	r12
    2372:	df 92       	push	r13
    2374:	ef 92       	push	r14
    2376:	ff 92       	push	r15
    2378:	0f 93       	push	r16
    237a:	1f 93       	push	r17
    237c:	2f 93       	push	r18
    237e:	3f 93       	push	r19
    2380:	4f 93       	push	r20
    2382:	5f 93       	push	r21
    2384:	6f 93       	push	r22
    2386:	7f 93       	push	r23
    2388:	8f 93       	push	r24
    238a:	9f 93       	push	r25
    238c:	af 93       	push	r26
    238e:	bf 93       	push	r27
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	ef 93       	push	r30
    2396:	ff 93       	push	r31
    2398:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    239c:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    23a0:	0d b6       	in	r0, 0x3d	; 61
    23a2:	0d 92       	st	X+, r0
    23a4:	0e b6       	in	r0, 0x3e	; 62
    23a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    23a8:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    23ac:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    23b0:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    23b4:	cd 91       	ld	r28, X+
    23b6:	cd bf       	out	0x3d, r28	; 61
    23b8:	dd 91       	ld	r29, X+
    23ba:	de bf       	out	0x3e, r29	; 62
    23bc:	ff 91       	pop	r31
    23be:	ef 91       	pop	r30
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	bf 91       	pop	r27
    23c6:	af 91       	pop	r26
    23c8:	9f 91       	pop	r25
    23ca:	8f 91       	pop	r24
    23cc:	7f 91       	pop	r23
    23ce:	6f 91       	pop	r22
    23d0:	5f 91       	pop	r21
    23d2:	4f 91       	pop	r20
    23d4:	3f 91       	pop	r19
    23d6:	2f 91       	pop	r18
    23d8:	1f 91       	pop	r17
    23da:	0f 91       	pop	r16
    23dc:	ff 90       	pop	r15
    23de:	ef 90       	pop	r14
    23e0:	df 90       	pop	r13
    23e2:	cf 90       	pop	r12
    23e4:	bf 90       	pop	r11
    23e6:	af 90       	pop	r10
    23e8:	9f 90       	pop	r9
    23ea:	8f 90       	pop	r8
    23ec:	7f 90       	pop	r7
    23ee:	6f 90       	pop	r6
    23f0:	5f 90       	pop	r5
    23f2:	4f 90       	pop	r4
    23f4:	3f 90       	pop	r3
    23f6:	2f 90       	pop	r2
    23f8:	1f 90       	pop	r1
    23fa:	0f 90       	pop	r0
    23fc:	0f be       	out	0x3f, r0	; 63
    23fe:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2400:	08 95       	ret

00002402 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2402:	0f 92       	push	r0
    2404:	0f b6       	in	r0, 0x3f	; 63
    2406:	f8 94       	cli
    2408:	0f 92       	push	r0
    240a:	1f 92       	push	r1
    240c:	11 24       	eor	r1, r1
    240e:	2f 92       	push	r2
    2410:	3f 92       	push	r3
    2412:	4f 92       	push	r4
    2414:	5f 92       	push	r5
    2416:	6f 92       	push	r6
    2418:	7f 92       	push	r7
    241a:	8f 92       	push	r8
    241c:	9f 92       	push	r9
    241e:	af 92       	push	r10
    2420:	bf 92       	push	r11
    2422:	cf 92       	push	r12
    2424:	df 92       	push	r13
    2426:	ef 92       	push	r14
    2428:	ff 92       	push	r15
    242a:	0f 93       	push	r16
    242c:	1f 93       	push	r17
    242e:	2f 93       	push	r18
    2430:	3f 93       	push	r19
    2432:	4f 93       	push	r20
    2434:	5f 93       	push	r21
    2436:	6f 93       	push	r22
    2438:	7f 93       	push	r23
    243a:	8f 93       	push	r24
    243c:	9f 93       	push	r25
    243e:	af 93       	push	r26
    2440:	bf 93       	push	r27
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
    2446:	ef 93       	push	r30
    2448:	ff 93       	push	r31
    244a:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    244e:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    2452:	0d b6       	in	r0, 0x3d	; 61
    2454:	0d 92       	st	X+, r0
    2456:	0e b6       	in	r0, 0x3e	; 62
    2458:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    245a:	0e 94 4d 04 	call	0x89a	; 0x89a <xTaskIncrementTick>
    245e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2460:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2464:	a0 91 3e 01 	lds	r26, 0x013E	; 0x80013e <__data_end>
    2468:	b0 91 3f 01 	lds	r27, 0x013F	; 0x80013f <__data_end+0x1>
    246c:	cd 91       	ld	r28, X+
    246e:	cd bf       	out	0x3d, r28	; 61
    2470:	dd 91       	ld	r29, X+
    2472:	de bf       	out	0x3e, r29	; 62
    2474:	ff 91       	pop	r31
    2476:	ef 91       	pop	r30
    2478:	df 91       	pop	r29
    247a:	cf 91       	pop	r28
    247c:	bf 91       	pop	r27
    247e:	af 91       	pop	r26
    2480:	9f 91       	pop	r25
    2482:	8f 91       	pop	r24
    2484:	7f 91       	pop	r23
    2486:	6f 91       	pop	r22
    2488:	5f 91       	pop	r21
    248a:	4f 91       	pop	r20
    248c:	3f 91       	pop	r19
    248e:	2f 91       	pop	r18
    2490:	1f 91       	pop	r17
    2492:	0f 91       	pop	r16
    2494:	ff 90       	pop	r15
    2496:	ef 90       	pop	r14
    2498:	df 90       	pop	r13
    249a:	cf 90       	pop	r12
    249c:	bf 90       	pop	r11
    249e:	af 90       	pop	r10
    24a0:	9f 90       	pop	r9
    24a2:	8f 90       	pop	r8
    24a4:	7f 90       	pop	r7
    24a6:	6f 90       	pop	r6
    24a8:	5f 90       	pop	r5
    24aa:	4f 90       	pop	r4
    24ac:	3f 90       	pop	r3
    24ae:	2f 90       	pop	r2
    24b0:	1f 90       	pop	r1
    24b2:	0f 90       	pop	r0
    24b4:	0f be       	out	0x3f, r0	; 63
    24b6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    24b8:	08 95       	ret

000024ba <__vector_11>:
    24ba:	0e 94 01 12 	call	0x2402	; 0x2402 <vPortYieldFromTick>
    24be:	18 95       	reti

000024c0 <main>:
static void vSerial(void* pvParameters);

FILE uart_file = FDEV_SETUP_STREAM(uart_transmit, uart_receive, _FDEV_SETUP_RW);

int main(void)
{
    24c0:	ef 92       	push	r14
    24c2:	ff 92       	push	r15
    24c4:	0f 93       	push	r16
    24c6:	cf 93       	push	r28
    24c8:	df 93       	push	r29
    24ca:	00 d0       	rcall	.+0      	; 0x24cc <main+0xc>
    24cc:	00 d0       	rcall	.+0      	; 0x24ce <main+0xe>
    24ce:	cd b7       	in	r28, 0x3d	; 61
    24d0:	de b7       	in	r29, 0x3e	; 62

    sei();
    24d2:	78 94       	sei

    xTaskHandle blink_handle;
    xTaskHandle serial_handle;

    xTaskCreate
    24d4:	ce 01       	movw	r24, r28
    24d6:	03 96       	adiw	r24, 0x03	; 3
    24d8:	7c 01       	movw	r14, r24
    24da:	02 e0       	ldi	r16, 0x02	; 2
    24dc:	20 e0       	ldi	r18, 0x00	; 0
    24de:	30 e0       	ldi	r19, 0x00	; 0
    24e0:	45 e5       	ldi	r20, 0x55	; 85
    24e2:	50 e0       	ldi	r21, 0x00	; 0
    24e4:	6b e2       	ldi	r22, 0x2B	; 43
    24e6:	71 e0       	ldi	r23, 0x01	; 1
    24e8:	8e e7       	ldi	r24, 0x7E	; 126
    24ea:	90 e0       	ldi	r25, 0x00	; 0
    24ec:	0e 94 19 02 	call	0x432	; 0x432 <xTaskCreate>
         NULL,
         mainLED_TASK_PRIORITY,
         &blink_handle
        );

    xTaskCreate
    24f0:	ce 01       	movw	r24, r28
    24f2:	01 96       	adiw	r24, 0x01	; 1
    24f4:	7c 01       	movw	r14, r24
    24f6:	01 e0       	ldi	r16, 0x01	; 1
    24f8:	20 e0       	ldi	r18, 0x00	; 0
    24fa:	30 e0       	ldi	r19, 0x00	; 0
    24fc:	4c eb       	ldi	r20, 0xBC	; 188
    24fe:	52 e0       	ldi	r21, 0x02	; 2
    2500:	61 e3       	ldi	r22, 0x31	; 49
    2502:	71 e0       	ldi	r23, 0x01	; 1
    2504:	83 e5       	ldi	r24, 0x53	; 83
    2506:	90 e0       	ldi	r25, 0x00	; 0
    2508:	0e 94 19 02 	call	0x432	; 0x432 <xTaskCreate>
         mainSERIAL_TASK_PRIORITY,
         &serial_handle
        );

    // Start scheduler.
    vTaskStartScheduler();
    250c:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskStartScheduler>

    return 0;
}
    2510:	80 e0       	ldi	r24, 0x00	; 0
    2512:	90 e0       	ldi	r25, 0x00	; 0
    2514:	0f 90       	pop	r0
    2516:	0f 90       	pop	r0
    2518:	0f 90       	pop	r0
    251a:	0f 90       	pop	r0
    251c:	df 91       	pop	r29
    251e:	cf 91       	pop	r28
    2520:	0f 91       	pop	r16
    2522:	ff 90       	pop	r15
    2524:	ef 90       	pop	r14
    2526:	08 95       	ret

00002528 <memcpy>:
    2528:	fb 01       	movw	r30, r22
    252a:	dc 01       	movw	r26, r24
    252c:	02 c0       	rjmp	.+4      	; 0x2532 <memcpy+0xa>
    252e:	01 90       	ld	r0, Z+
    2530:	0d 92       	st	X+, r0
    2532:	41 50       	subi	r20, 0x01	; 1
    2534:	50 40       	sbci	r21, 0x00	; 0
    2536:	d8 f7       	brcc	.-10     	; 0x252e <memcpy+0x6>
    2538:	08 95       	ret

0000253a <fgetc>:
    253a:	cf 93       	push	r28
    253c:	df 93       	push	r29
    253e:	ec 01       	movw	r28, r24
    2540:	2b 81       	ldd	r18, Y+3	; 0x03
    2542:	20 ff       	sbrs	r18, 0
    2544:	33 c0       	rjmp	.+102    	; 0x25ac <fgetc+0x72>
    2546:	26 ff       	sbrs	r18, 6
    2548:	0a c0       	rjmp	.+20     	; 0x255e <fgetc+0x24>
    254a:	2f 7b       	andi	r18, 0xBF	; 191
    254c:	2b 83       	std	Y+3, r18	; 0x03
    254e:	8e 81       	ldd	r24, Y+6	; 0x06
    2550:	9f 81       	ldd	r25, Y+7	; 0x07
    2552:	01 96       	adiw	r24, 0x01	; 1
    2554:	9f 83       	std	Y+7, r25	; 0x07
    2556:	8e 83       	std	Y+6, r24	; 0x06
    2558:	8a 81       	ldd	r24, Y+2	; 0x02
    255a:	90 e0       	ldi	r25, 0x00	; 0
    255c:	29 c0       	rjmp	.+82     	; 0x25b0 <fgetc+0x76>
    255e:	22 ff       	sbrs	r18, 2
    2560:	0f c0       	rjmp	.+30     	; 0x2580 <fgetc+0x46>
    2562:	e8 81       	ld	r30, Y
    2564:	f9 81       	ldd	r31, Y+1	; 0x01
    2566:	80 81       	ld	r24, Z
    2568:	08 2e       	mov	r0, r24
    256a:	00 0c       	add	r0, r0
    256c:	99 0b       	sbc	r25, r25
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	19 f4       	brne	.+6      	; 0x2578 <fgetc+0x3e>
    2572:	20 62       	ori	r18, 0x20	; 32
    2574:	2b 83       	std	Y+3, r18	; 0x03
    2576:	1a c0       	rjmp	.+52     	; 0x25ac <fgetc+0x72>
    2578:	31 96       	adiw	r30, 0x01	; 1
    257a:	f9 83       	std	Y+1, r31	; 0x01
    257c:	e8 83       	st	Y, r30
    257e:	0e c0       	rjmp	.+28     	; 0x259c <fgetc+0x62>
    2580:	ea 85       	ldd	r30, Y+10	; 0x0a
    2582:	fb 85       	ldd	r31, Y+11	; 0x0b
    2584:	09 95       	icall
    2586:	97 ff       	sbrs	r25, 7
    2588:	09 c0       	rjmp	.+18     	; 0x259c <fgetc+0x62>
    258a:	2b 81       	ldd	r18, Y+3	; 0x03
    258c:	01 96       	adiw	r24, 0x01	; 1
    258e:	11 f0       	breq	.+4      	; 0x2594 <fgetc+0x5a>
    2590:	80 e2       	ldi	r24, 0x20	; 32
    2592:	01 c0       	rjmp	.+2      	; 0x2596 <fgetc+0x5c>
    2594:	80 e1       	ldi	r24, 0x10	; 16
    2596:	82 2b       	or	r24, r18
    2598:	8b 83       	std	Y+3, r24	; 0x03
    259a:	08 c0       	rjmp	.+16     	; 0x25ac <fgetc+0x72>
    259c:	2e 81       	ldd	r18, Y+6	; 0x06
    259e:	3f 81       	ldd	r19, Y+7	; 0x07
    25a0:	2f 5f       	subi	r18, 0xFF	; 255
    25a2:	3f 4f       	sbci	r19, 0xFF	; 255
    25a4:	3f 83       	std	Y+7, r19	; 0x07
    25a6:	2e 83       	std	Y+6, r18	; 0x06
    25a8:	99 27       	eor	r25, r25
    25aa:	02 c0       	rjmp	.+4      	; 0x25b0 <fgetc+0x76>
    25ac:	8f ef       	ldi	r24, 0xFF	; 255
    25ae:	9f ef       	ldi	r25, 0xFF	; 255
    25b0:	df 91       	pop	r29
    25b2:	cf 91       	pop	r28
    25b4:	08 95       	ret

000025b6 <printf>:
    25b6:	a0 e0       	ldi	r26, 0x00	; 0
    25b8:	b0 e0       	ldi	r27, 0x00	; 0
    25ba:	e1 ee       	ldi	r30, 0xE1	; 225
    25bc:	f2 e1       	ldi	r31, 0x12	; 18
    25be:	0c 94 c2 15 	jmp	0x2b84	; 0x2b84 <__prologue_saves__+0x20>
    25c2:	ae 01       	movw	r20, r28
    25c4:	4b 5f       	subi	r20, 0xFB	; 251
    25c6:	5f 4f       	sbci	r21, 0xFF	; 255
    25c8:	fa 01       	movw	r30, r20
    25ca:	61 91       	ld	r22, Z+
    25cc:	71 91       	ld	r23, Z+
    25ce:	af 01       	movw	r20, r30
    25d0:	80 91 c4 07 	lds	r24, 0x07C4	; 0x8007c4 <__iob+0x2>
    25d4:	90 91 c5 07 	lds	r25, 0x07C5	; 0x8007c5 <__iob+0x3>
    25d8:	0e 94 21 13 	call	0x2642	; 0x2642 <vfprintf>
    25dc:	e2 e0       	ldi	r30, 0x02	; 2
    25de:	0c 94 de 15 	jmp	0x2bbc	; 0x2bbc <__epilogue_restores__+0x20>

000025e2 <puts>:
    25e2:	0f 93       	push	r16
    25e4:	1f 93       	push	r17
    25e6:	cf 93       	push	r28
    25e8:	df 93       	push	r29
    25ea:	e0 91 c4 07 	lds	r30, 0x07C4	; 0x8007c4 <__iob+0x2>
    25ee:	f0 91 c5 07 	lds	r31, 0x07C5	; 0x8007c5 <__iob+0x3>
    25f2:	23 81       	ldd	r18, Z+3	; 0x03
    25f4:	21 ff       	sbrs	r18, 1
    25f6:	1b c0       	rjmp	.+54     	; 0x262e <puts+0x4c>
    25f8:	8c 01       	movw	r16, r24
    25fa:	d0 e0       	ldi	r29, 0x00	; 0
    25fc:	c0 e0       	ldi	r28, 0x00	; 0
    25fe:	f8 01       	movw	r30, r16
    2600:	81 91       	ld	r24, Z+
    2602:	8f 01       	movw	r16, r30
    2604:	60 91 c4 07 	lds	r22, 0x07C4	; 0x8007c4 <__iob+0x2>
    2608:	70 91 c5 07 	lds	r23, 0x07C5	; 0x8007c5 <__iob+0x3>
    260c:	db 01       	movw	r26, r22
    260e:	18 96       	adiw	r26, 0x08	; 8
    2610:	ed 91       	ld	r30, X+
    2612:	fc 91       	ld	r31, X
    2614:	19 97       	sbiw	r26, 0x09	; 9
    2616:	88 23       	and	r24, r24
    2618:	31 f0       	breq	.+12     	; 0x2626 <puts+0x44>
    261a:	09 95       	icall
    261c:	89 2b       	or	r24, r25
    261e:	79 f3       	breq	.-34     	; 0x25fe <puts+0x1c>
    2620:	df ef       	ldi	r29, 0xFF	; 255
    2622:	cf ef       	ldi	r28, 0xFF	; 255
    2624:	ec cf       	rjmp	.-40     	; 0x25fe <puts+0x1c>
    2626:	8a e0       	ldi	r24, 0x0A	; 10
    2628:	09 95       	icall
    262a:	89 2b       	or	r24, r25
    262c:	19 f0       	breq	.+6      	; 0x2634 <puts+0x52>
    262e:	8f ef       	ldi	r24, 0xFF	; 255
    2630:	9f ef       	ldi	r25, 0xFF	; 255
    2632:	02 c0       	rjmp	.+4      	; 0x2638 <puts+0x56>
    2634:	8d 2f       	mov	r24, r29
    2636:	9c 2f       	mov	r25, r28
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	1f 91       	pop	r17
    263e:	0f 91       	pop	r16
    2640:	08 95       	ret

00002642 <vfprintf>:
    2642:	ab e0       	ldi	r26, 0x0B	; 11
    2644:	b0 e0       	ldi	r27, 0x00	; 0
    2646:	e7 e2       	ldi	r30, 0x27	; 39
    2648:	f3 e1       	ldi	r31, 0x13	; 19
    264a:	0c 94 b2 15 	jmp	0x2b64	; 0x2b64 <__prologue_saves__>
    264e:	6c 01       	movw	r12, r24
    2650:	7b 01       	movw	r14, r22
    2652:	8a 01       	movw	r16, r20
    2654:	fc 01       	movw	r30, r24
    2656:	17 82       	std	Z+7, r1	; 0x07
    2658:	16 82       	std	Z+6, r1	; 0x06
    265a:	83 81       	ldd	r24, Z+3	; 0x03
    265c:	81 ff       	sbrs	r24, 1
    265e:	cc c1       	rjmp	.+920    	; 0x29f8 <vfprintf+0x3b6>
    2660:	ce 01       	movw	r24, r28
    2662:	01 96       	adiw	r24, 0x01	; 1
    2664:	3c 01       	movw	r6, r24
    2666:	f6 01       	movw	r30, r12
    2668:	93 81       	ldd	r25, Z+3	; 0x03
    266a:	f7 01       	movw	r30, r14
    266c:	93 fd       	sbrc	r25, 3
    266e:	85 91       	lpm	r24, Z+
    2670:	93 ff       	sbrs	r25, 3
    2672:	81 91       	ld	r24, Z+
    2674:	7f 01       	movw	r14, r30
    2676:	88 23       	and	r24, r24
    2678:	09 f4       	brne	.+2      	; 0x267c <vfprintf+0x3a>
    267a:	ba c1       	rjmp	.+884    	; 0x29f0 <vfprintf+0x3ae>
    267c:	85 32       	cpi	r24, 0x25	; 37
    267e:	39 f4       	brne	.+14     	; 0x268e <vfprintf+0x4c>
    2680:	93 fd       	sbrc	r25, 3
    2682:	85 91       	lpm	r24, Z+
    2684:	93 ff       	sbrs	r25, 3
    2686:	81 91       	ld	r24, Z+
    2688:	7f 01       	movw	r14, r30
    268a:	85 32       	cpi	r24, 0x25	; 37
    268c:	29 f4       	brne	.+10     	; 0x2698 <vfprintf+0x56>
    268e:	b6 01       	movw	r22, r12
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    2696:	e7 cf       	rjmp	.-50     	; 0x2666 <vfprintf+0x24>
    2698:	91 2c       	mov	r9, r1
    269a:	21 2c       	mov	r2, r1
    269c:	31 2c       	mov	r3, r1
    269e:	ff e1       	ldi	r31, 0x1F	; 31
    26a0:	f3 15       	cp	r31, r3
    26a2:	d8 f0       	brcs	.+54     	; 0x26da <vfprintf+0x98>
    26a4:	8b 32       	cpi	r24, 0x2B	; 43
    26a6:	79 f0       	breq	.+30     	; 0x26c6 <vfprintf+0x84>
    26a8:	38 f4       	brcc	.+14     	; 0x26b8 <vfprintf+0x76>
    26aa:	80 32       	cpi	r24, 0x20	; 32
    26ac:	79 f0       	breq	.+30     	; 0x26cc <vfprintf+0x8a>
    26ae:	83 32       	cpi	r24, 0x23	; 35
    26b0:	a1 f4       	brne	.+40     	; 0x26da <vfprintf+0x98>
    26b2:	23 2d       	mov	r18, r3
    26b4:	20 61       	ori	r18, 0x10	; 16
    26b6:	1d c0       	rjmp	.+58     	; 0x26f2 <vfprintf+0xb0>
    26b8:	8d 32       	cpi	r24, 0x2D	; 45
    26ba:	61 f0       	breq	.+24     	; 0x26d4 <vfprintf+0x92>
    26bc:	80 33       	cpi	r24, 0x30	; 48
    26be:	69 f4       	brne	.+26     	; 0x26da <vfprintf+0x98>
    26c0:	23 2d       	mov	r18, r3
    26c2:	21 60       	ori	r18, 0x01	; 1
    26c4:	16 c0       	rjmp	.+44     	; 0x26f2 <vfprintf+0xb0>
    26c6:	83 2d       	mov	r24, r3
    26c8:	82 60       	ori	r24, 0x02	; 2
    26ca:	38 2e       	mov	r3, r24
    26cc:	e3 2d       	mov	r30, r3
    26ce:	e4 60       	ori	r30, 0x04	; 4
    26d0:	3e 2e       	mov	r3, r30
    26d2:	2a c0       	rjmp	.+84     	; 0x2728 <vfprintf+0xe6>
    26d4:	f3 2d       	mov	r31, r3
    26d6:	f8 60       	ori	r31, 0x08	; 8
    26d8:	1d c0       	rjmp	.+58     	; 0x2714 <vfprintf+0xd2>
    26da:	37 fc       	sbrc	r3, 7
    26dc:	2d c0       	rjmp	.+90     	; 0x2738 <vfprintf+0xf6>
    26de:	20 ed       	ldi	r18, 0xD0	; 208
    26e0:	28 0f       	add	r18, r24
    26e2:	2a 30       	cpi	r18, 0x0A	; 10
    26e4:	40 f0       	brcs	.+16     	; 0x26f6 <vfprintf+0xb4>
    26e6:	8e 32       	cpi	r24, 0x2E	; 46
    26e8:	b9 f4       	brne	.+46     	; 0x2718 <vfprintf+0xd6>
    26ea:	36 fc       	sbrc	r3, 6
    26ec:	81 c1       	rjmp	.+770    	; 0x29f0 <vfprintf+0x3ae>
    26ee:	23 2d       	mov	r18, r3
    26f0:	20 64       	ori	r18, 0x40	; 64
    26f2:	32 2e       	mov	r3, r18
    26f4:	19 c0       	rjmp	.+50     	; 0x2728 <vfprintf+0xe6>
    26f6:	36 fe       	sbrs	r3, 6
    26f8:	06 c0       	rjmp	.+12     	; 0x2706 <vfprintf+0xc4>
    26fa:	8a e0       	ldi	r24, 0x0A	; 10
    26fc:	98 9e       	mul	r9, r24
    26fe:	20 0d       	add	r18, r0
    2700:	11 24       	eor	r1, r1
    2702:	92 2e       	mov	r9, r18
    2704:	11 c0       	rjmp	.+34     	; 0x2728 <vfprintf+0xe6>
    2706:	ea e0       	ldi	r30, 0x0A	; 10
    2708:	2e 9e       	mul	r2, r30
    270a:	20 0d       	add	r18, r0
    270c:	11 24       	eor	r1, r1
    270e:	22 2e       	mov	r2, r18
    2710:	f3 2d       	mov	r31, r3
    2712:	f0 62       	ori	r31, 0x20	; 32
    2714:	3f 2e       	mov	r3, r31
    2716:	08 c0       	rjmp	.+16     	; 0x2728 <vfprintf+0xe6>
    2718:	8c 36       	cpi	r24, 0x6C	; 108
    271a:	21 f4       	brne	.+8      	; 0x2724 <vfprintf+0xe2>
    271c:	83 2d       	mov	r24, r3
    271e:	80 68       	ori	r24, 0x80	; 128
    2720:	38 2e       	mov	r3, r24
    2722:	02 c0       	rjmp	.+4      	; 0x2728 <vfprintf+0xe6>
    2724:	88 36       	cpi	r24, 0x68	; 104
    2726:	41 f4       	brne	.+16     	; 0x2738 <vfprintf+0xf6>
    2728:	f7 01       	movw	r30, r14
    272a:	93 fd       	sbrc	r25, 3
    272c:	85 91       	lpm	r24, Z+
    272e:	93 ff       	sbrs	r25, 3
    2730:	81 91       	ld	r24, Z+
    2732:	7f 01       	movw	r14, r30
    2734:	81 11       	cpse	r24, r1
    2736:	b3 cf       	rjmp	.-154    	; 0x269e <vfprintf+0x5c>
    2738:	98 2f       	mov	r25, r24
    273a:	9f 7d       	andi	r25, 0xDF	; 223
    273c:	95 54       	subi	r25, 0x45	; 69
    273e:	93 30       	cpi	r25, 0x03	; 3
    2740:	28 f4       	brcc	.+10     	; 0x274c <vfprintf+0x10a>
    2742:	0c 5f       	subi	r16, 0xFC	; 252
    2744:	1f 4f       	sbci	r17, 0xFF	; 255
    2746:	9f e3       	ldi	r25, 0x3F	; 63
    2748:	99 83       	std	Y+1, r25	; 0x01
    274a:	0d c0       	rjmp	.+26     	; 0x2766 <vfprintf+0x124>
    274c:	83 36       	cpi	r24, 0x63	; 99
    274e:	31 f0       	breq	.+12     	; 0x275c <vfprintf+0x11a>
    2750:	83 37       	cpi	r24, 0x73	; 115
    2752:	71 f0       	breq	.+28     	; 0x2770 <vfprintf+0x12e>
    2754:	83 35       	cpi	r24, 0x53	; 83
    2756:	09 f0       	breq	.+2      	; 0x275a <vfprintf+0x118>
    2758:	59 c0       	rjmp	.+178    	; 0x280c <vfprintf+0x1ca>
    275a:	21 c0       	rjmp	.+66     	; 0x279e <vfprintf+0x15c>
    275c:	f8 01       	movw	r30, r16
    275e:	80 81       	ld	r24, Z
    2760:	89 83       	std	Y+1, r24	; 0x01
    2762:	0e 5f       	subi	r16, 0xFE	; 254
    2764:	1f 4f       	sbci	r17, 0xFF	; 255
    2766:	88 24       	eor	r8, r8
    2768:	83 94       	inc	r8
    276a:	91 2c       	mov	r9, r1
    276c:	53 01       	movw	r10, r6
    276e:	13 c0       	rjmp	.+38     	; 0x2796 <vfprintf+0x154>
    2770:	28 01       	movw	r4, r16
    2772:	f2 e0       	ldi	r31, 0x02	; 2
    2774:	4f 0e       	add	r4, r31
    2776:	51 1c       	adc	r5, r1
    2778:	f8 01       	movw	r30, r16
    277a:	a0 80       	ld	r10, Z
    277c:	b1 80       	ldd	r11, Z+1	; 0x01
    277e:	36 fe       	sbrs	r3, 6
    2780:	03 c0       	rjmp	.+6      	; 0x2788 <vfprintf+0x146>
    2782:	69 2d       	mov	r22, r9
    2784:	70 e0       	ldi	r23, 0x00	; 0
    2786:	02 c0       	rjmp	.+4      	; 0x278c <vfprintf+0x14a>
    2788:	6f ef       	ldi	r22, 0xFF	; 255
    278a:	7f ef       	ldi	r23, 0xFF	; 255
    278c:	c5 01       	movw	r24, r10
    278e:	0e 94 0d 15 	call	0x2a1a	; 0x2a1a <strnlen>
    2792:	4c 01       	movw	r8, r24
    2794:	82 01       	movw	r16, r4
    2796:	f3 2d       	mov	r31, r3
    2798:	ff 77       	andi	r31, 0x7F	; 127
    279a:	3f 2e       	mov	r3, r31
    279c:	16 c0       	rjmp	.+44     	; 0x27ca <vfprintf+0x188>
    279e:	28 01       	movw	r4, r16
    27a0:	22 e0       	ldi	r18, 0x02	; 2
    27a2:	42 0e       	add	r4, r18
    27a4:	51 1c       	adc	r5, r1
    27a6:	f8 01       	movw	r30, r16
    27a8:	a0 80       	ld	r10, Z
    27aa:	b1 80       	ldd	r11, Z+1	; 0x01
    27ac:	36 fe       	sbrs	r3, 6
    27ae:	03 c0       	rjmp	.+6      	; 0x27b6 <vfprintf+0x174>
    27b0:	69 2d       	mov	r22, r9
    27b2:	70 e0       	ldi	r23, 0x00	; 0
    27b4:	02 c0       	rjmp	.+4      	; 0x27ba <vfprintf+0x178>
    27b6:	6f ef       	ldi	r22, 0xFF	; 255
    27b8:	7f ef       	ldi	r23, 0xFF	; 255
    27ba:	c5 01       	movw	r24, r10
    27bc:	0e 94 02 15 	call	0x2a04	; 0x2a04 <strnlen_P>
    27c0:	4c 01       	movw	r8, r24
    27c2:	f3 2d       	mov	r31, r3
    27c4:	f0 68       	ori	r31, 0x80	; 128
    27c6:	3f 2e       	mov	r3, r31
    27c8:	82 01       	movw	r16, r4
    27ca:	33 fc       	sbrc	r3, 3
    27cc:	1b c0       	rjmp	.+54     	; 0x2804 <vfprintf+0x1c2>
    27ce:	82 2d       	mov	r24, r2
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	88 16       	cp	r8, r24
    27d4:	99 06       	cpc	r9, r25
    27d6:	b0 f4       	brcc	.+44     	; 0x2804 <vfprintf+0x1c2>
    27d8:	b6 01       	movw	r22, r12
    27da:	80 e2       	ldi	r24, 0x20	; 32
    27dc:	90 e0       	ldi	r25, 0x00	; 0
    27de:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    27e2:	2a 94       	dec	r2
    27e4:	f4 cf       	rjmp	.-24     	; 0x27ce <vfprintf+0x18c>
    27e6:	f5 01       	movw	r30, r10
    27e8:	37 fc       	sbrc	r3, 7
    27ea:	85 91       	lpm	r24, Z+
    27ec:	37 fe       	sbrs	r3, 7
    27ee:	81 91       	ld	r24, Z+
    27f0:	5f 01       	movw	r10, r30
    27f2:	b6 01       	movw	r22, r12
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    27fa:	21 10       	cpse	r2, r1
    27fc:	2a 94       	dec	r2
    27fe:	21 e0       	ldi	r18, 0x01	; 1
    2800:	82 1a       	sub	r8, r18
    2802:	91 08       	sbc	r9, r1
    2804:	81 14       	cp	r8, r1
    2806:	91 04       	cpc	r9, r1
    2808:	71 f7       	brne	.-36     	; 0x27e6 <vfprintf+0x1a4>
    280a:	e8 c0       	rjmp	.+464    	; 0x29dc <vfprintf+0x39a>
    280c:	84 36       	cpi	r24, 0x64	; 100
    280e:	11 f0       	breq	.+4      	; 0x2814 <vfprintf+0x1d2>
    2810:	89 36       	cpi	r24, 0x69	; 105
    2812:	41 f5       	brne	.+80     	; 0x2864 <vfprintf+0x222>
    2814:	f8 01       	movw	r30, r16
    2816:	37 fe       	sbrs	r3, 7
    2818:	07 c0       	rjmp	.+14     	; 0x2828 <vfprintf+0x1e6>
    281a:	60 81       	ld	r22, Z
    281c:	71 81       	ldd	r23, Z+1	; 0x01
    281e:	82 81       	ldd	r24, Z+2	; 0x02
    2820:	93 81       	ldd	r25, Z+3	; 0x03
    2822:	0c 5f       	subi	r16, 0xFC	; 252
    2824:	1f 4f       	sbci	r17, 0xFF	; 255
    2826:	08 c0       	rjmp	.+16     	; 0x2838 <vfprintf+0x1f6>
    2828:	60 81       	ld	r22, Z
    282a:	71 81       	ldd	r23, Z+1	; 0x01
    282c:	07 2e       	mov	r0, r23
    282e:	00 0c       	add	r0, r0
    2830:	88 0b       	sbc	r24, r24
    2832:	99 0b       	sbc	r25, r25
    2834:	0e 5f       	subi	r16, 0xFE	; 254
    2836:	1f 4f       	sbci	r17, 0xFF	; 255
    2838:	f3 2d       	mov	r31, r3
    283a:	ff 76       	andi	r31, 0x6F	; 111
    283c:	3f 2e       	mov	r3, r31
    283e:	97 ff       	sbrs	r25, 7
    2840:	09 c0       	rjmp	.+18     	; 0x2854 <vfprintf+0x212>
    2842:	90 95       	com	r25
    2844:	80 95       	com	r24
    2846:	70 95       	com	r23
    2848:	61 95       	neg	r22
    284a:	7f 4f       	sbci	r23, 0xFF	; 255
    284c:	8f 4f       	sbci	r24, 0xFF	; 255
    284e:	9f 4f       	sbci	r25, 0xFF	; 255
    2850:	f0 68       	ori	r31, 0x80	; 128
    2852:	3f 2e       	mov	r3, r31
    2854:	2a e0       	ldi	r18, 0x0A	; 10
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	a3 01       	movw	r20, r6
    285a:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <__ultoa_invert>
    285e:	88 2e       	mov	r8, r24
    2860:	86 18       	sub	r8, r6
    2862:	45 c0       	rjmp	.+138    	; 0x28ee <vfprintf+0x2ac>
    2864:	85 37       	cpi	r24, 0x75	; 117
    2866:	31 f4       	brne	.+12     	; 0x2874 <vfprintf+0x232>
    2868:	23 2d       	mov	r18, r3
    286a:	2f 7e       	andi	r18, 0xEF	; 239
    286c:	b2 2e       	mov	r11, r18
    286e:	2a e0       	ldi	r18, 0x0A	; 10
    2870:	30 e0       	ldi	r19, 0x00	; 0
    2872:	25 c0       	rjmp	.+74     	; 0x28be <vfprintf+0x27c>
    2874:	93 2d       	mov	r25, r3
    2876:	99 7f       	andi	r25, 0xF9	; 249
    2878:	b9 2e       	mov	r11, r25
    287a:	8f 36       	cpi	r24, 0x6F	; 111
    287c:	c1 f0       	breq	.+48     	; 0x28ae <vfprintf+0x26c>
    287e:	18 f4       	brcc	.+6      	; 0x2886 <vfprintf+0x244>
    2880:	88 35       	cpi	r24, 0x58	; 88
    2882:	79 f0       	breq	.+30     	; 0x28a2 <vfprintf+0x260>
    2884:	b5 c0       	rjmp	.+362    	; 0x29f0 <vfprintf+0x3ae>
    2886:	80 37       	cpi	r24, 0x70	; 112
    2888:	19 f0       	breq	.+6      	; 0x2890 <vfprintf+0x24e>
    288a:	88 37       	cpi	r24, 0x78	; 120
    288c:	21 f0       	breq	.+8      	; 0x2896 <vfprintf+0x254>
    288e:	b0 c0       	rjmp	.+352    	; 0x29f0 <vfprintf+0x3ae>
    2890:	e9 2f       	mov	r30, r25
    2892:	e0 61       	ori	r30, 0x10	; 16
    2894:	be 2e       	mov	r11, r30
    2896:	b4 fe       	sbrs	r11, 4
    2898:	0d c0       	rjmp	.+26     	; 0x28b4 <vfprintf+0x272>
    289a:	fb 2d       	mov	r31, r11
    289c:	f4 60       	ori	r31, 0x04	; 4
    289e:	bf 2e       	mov	r11, r31
    28a0:	09 c0       	rjmp	.+18     	; 0x28b4 <vfprintf+0x272>
    28a2:	34 fe       	sbrs	r3, 4
    28a4:	0a c0       	rjmp	.+20     	; 0x28ba <vfprintf+0x278>
    28a6:	29 2f       	mov	r18, r25
    28a8:	26 60       	ori	r18, 0x06	; 6
    28aa:	b2 2e       	mov	r11, r18
    28ac:	06 c0       	rjmp	.+12     	; 0x28ba <vfprintf+0x278>
    28ae:	28 e0       	ldi	r18, 0x08	; 8
    28b0:	30 e0       	ldi	r19, 0x00	; 0
    28b2:	05 c0       	rjmp	.+10     	; 0x28be <vfprintf+0x27c>
    28b4:	20 e1       	ldi	r18, 0x10	; 16
    28b6:	30 e0       	ldi	r19, 0x00	; 0
    28b8:	02 c0       	rjmp	.+4      	; 0x28be <vfprintf+0x27c>
    28ba:	20 e1       	ldi	r18, 0x10	; 16
    28bc:	32 e0       	ldi	r19, 0x02	; 2
    28be:	f8 01       	movw	r30, r16
    28c0:	b7 fe       	sbrs	r11, 7
    28c2:	07 c0       	rjmp	.+14     	; 0x28d2 <vfprintf+0x290>
    28c4:	60 81       	ld	r22, Z
    28c6:	71 81       	ldd	r23, Z+1	; 0x01
    28c8:	82 81       	ldd	r24, Z+2	; 0x02
    28ca:	93 81       	ldd	r25, Z+3	; 0x03
    28cc:	0c 5f       	subi	r16, 0xFC	; 252
    28ce:	1f 4f       	sbci	r17, 0xFF	; 255
    28d0:	06 c0       	rjmp	.+12     	; 0x28de <vfprintf+0x29c>
    28d2:	60 81       	ld	r22, Z
    28d4:	71 81       	ldd	r23, Z+1	; 0x01
    28d6:	80 e0       	ldi	r24, 0x00	; 0
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	0e 5f       	subi	r16, 0xFE	; 254
    28dc:	1f 4f       	sbci	r17, 0xFF	; 255
    28de:	a3 01       	movw	r20, r6
    28e0:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <__ultoa_invert>
    28e4:	88 2e       	mov	r8, r24
    28e6:	86 18       	sub	r8, r6
    28e8:	fb 2d       	mov	r31, r11
    28ea:	ff 77       	andi	r31, 0x7F	; 127
    28ec:	3f 2e       	mov	r3, r31
    28ee:	36 fe       	sbrs	r3, 6
    28f0:	0d c0       	rjmp	.+26     	; 0x290c <vfprintf+0x2ca>
    28f2:	23 2d       	mov	r18, r3
    28f4:	2e 7f       	andi	r18, 0xFE	; 254
    28f6:	a2 2e       	mov	r10, r18
    28f8:	89 14       	cp	r8, r9
    28fa:	58 f4       	brcc	.+22     	; 0x2912 <vfprintf+0x2d0>
    28fc:	34 fe       	sbrs	r3, 4
    28fe:	0b c0       	rjmp	.+22     	; 0x2916 <vfprintf+0x2d4>
    2900:	32 fc       	sbrc	r3, 2
    2902:	09 c0       	rjmp	.+18     	; 0x2916 <vfprintf+0x2d4>
    2904:	83 2d       	mov	r24, r3
    2906:	8e 7e       	andi	r24, 0xEE	; 238
    2908:	a8 2e       	mov	r10, r24
    290a:	05 c0       	rjmp	.+10     	; 0x2916 <vfprintf+0x2d4>
    290c:	b8 2c       	mov	r11, r8
    290e:	a3 2c       	mov	r10, r3
    2910:	03 c0       	rjmp	.+6      	; 0x2918 <vfprintf+0x2d6>
    2912:	b8 2c       	mov	r11, r8
    2914:	01 c0       	rjmp	.+2      	; 0x2918 <vfprintf+0x2d6>
    2916:	b9 2c       	mov	r11, r9
    2918:	a4 fe       	sbrs	r10, 4
    291a:	0f c0       	rjmp	.+30     	; 0x293a <vfprintf+0x2f8>
    291c:	fe 01       	movw	r30, r28
    291e:	e8 0d       	add	r30, r8
    2920:	f1 1d       	adc	r31, r1
    2922:	80 81       	ld	r24, Z
    2924:	80 33       	cpi	r24, 0x30	; 48
    2926:	21 f4       	brne	.+8      	; 0x2930 <vfprintf+0x2ee>
    2928:	9a 2d       	mov	r25, r10
    292a:	99 7e       	andi	r25, 0xE9	; 233
    292c:	a9 2e       	mov	r10, r25
    292e:	09 c0       	rjmp	.+18     	; 0x2942 <vfprintf+0x300>
    2930:	a2 fe       	sbrs	r10, 2
    2932:	06 c0       	rjmp	.+12     	; 0x2940 <vfprintf+0x2fe>
    2934:	b3 94       	inc	r11
    2936:	b3 94       	inc	r11
    2938:	04 c0       	rjmp	.+8      	; 0x2942 <vfprintf+0x300>
    293a:	8a 2d       	mov	r24, r10
    293c:	86 78       	andi	r24, 0x86	; 134
    293e:	09 f0       	breq	.+2      	; 0x2942 <vfprintf+0x300>
    2940:	b3 94       	inc	r11
    2942:	a3 fc       	sbrc	r10, 3
    2944:	11 c0       	rjmp	.+34     	; 0x2968 <vfprintf+0x326>
    2946:	a0 fe       	sbrs	r10, 0
    2948:	06 c0       	rjmp	.+12     	; 0x2956 <vfprintf+0x314>
    294a:	b2 14       	cp	r11, r2
    294c:	88 f4       	brcc	.+34     	; 0x2970 <vfprintf+0x32e>
    294e:	28 0c       	add	r2, r8
    2950:	92 2c       	mov	r9, r2
    2952:	9b 18       	sub	r9, r11
    2954:	0e c0       	rjmp	.+28     	; 0x2972 <vfprintf+0x330>
    2956:	b2 14       	cp	r11, r2
    2958:	60 f4       	brcc	.+24     	; 0x2972 <vfprintf+0x330>
    295a:	b6 01       	movw	r22, r12
    295c:	80 e2       	ldi	r24, 0x20	; 32
    295e:	90 e0       	ldi	r25, 0x00	; 0
    2960:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    2964:	b3 94       	inc	r11
    2966:	f7 cf       	rjmp	.-18     	; 0x2956 <vfprintf+0x314>
    2968:	b2 14       	cp	r11, r2
    296a:	18 f4       	brcc	.+6      	; 0x2972 <vfprintf+0x330>
    296c:	2b 18       	sub	r2, r11
    296e:	02 c0       	rjmp	.+4      	; 0x2974 <vfprintf+0x332>
    2970:	98 2c       	mov	r9, r8
    2972:	21 2c       	mov	r2, r1
    2974:	a4 fe       	sbrs	r10, 4
    2976:	10 c0       	rjmp	.+32     	; 0x2998 <vfprintf+0x356>
    2978:	b6 01       	movw	r22, r12
    297a:	80 e3       	ldi	r24, 0x30	; 48
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    2982:	a2 fe       	sbrs	r10, 2
    2984:	17 c0       	rjmp	.+46     	; 0x29b4 <vfprintf+0x372>
    2986:	a1 fc       	sbrc	r10, 1
    2988:	03 c0       	rjmp	.+6      	; 0x2990 <vfprintf+0x34e>
    298a:	88 e7       	ldi	r24, 0x78	; 120
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	02 c0       	rjmp	.+4      	; 0x2994 <vfprintf+0x352>
    2990:	88 e5       	ldi	r24, 0x58	; 88
    2992:	90 e0       	ldi	r25, 0x00	; 0
    2994:	b6 01       	movw	r22, r12
    2996:	0c c0       	rjmp	.+24     	; 0x29b0 <vfprintf+0x36e>
    2998:	8a 2d       	mov	r24, r10
    299a:	86 78       	andi	r24, 0x86	; 134
    299c:	59 f0       	breq	.+22     	; 0x29b4 <vfprintf+0x372>
    299e:	a1 fe       	sbrs	r10, 1
    29a0:	02 c0       	rjmp	.+4      	; 0x29a6 <vfprintf+0x364>
    29a2:	8b e2       	ldi	r24, 0x2B	; 43
    29a4:	01 c0       	rjmp	.+2      	; 0x29a8 <vfprintf+0x366>
    29a6:	80 e2       	ldi	r24, 0x20	; 32
    29a8:	a7 fc       	sbrc	r10, 7
    29aa:	8d e2       	ldi	r24, 0x2D	; 45
    29ac:	b6 01       	movw	r22, r12
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    29b4:	89 14       	cp	r8, r9
    29b6:	38 f4       	brcc	.+14     	; 0x29c6 <vfprintf+0x384>
    29b8:	b6 01       	movw	r22, r12
    29ba:	80 e3       	ldi	r24, 0x30	; 48
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    29c2:	9a 94       	dec	r9
    29c4:	f7 cf       	rjmp	.-18     	; 0x29b4 <vfprintf+0x372>
    29c6:	8a 94       	dec	r8
    29c8:	f3 01       	movw	r30, r6
    29ca:	e8 0d       	add	r30, r8
    29cc:	f1 1d       	adc	r31, r1
    29ce:	80 81       	ld	r24, Z
    29d0:	b6 01       	movw	r22, r12
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    29d8:	81 10       	cpse	r8, r1
    29da:	f5 cf       	rjmp	.-22     	; 0x29c6 <vfprintf+0x384>
    29dc:	22 20       	and	r2, r2
    29de:	09 f4       	brne	.+2      	; 0x29e2 <vfprintf+0x3a0>
    29e0:	42 ce       	rjmp	.-892    	; 0x2666 <vfprintf+0x24>
    29e2:	b6 01       	movw	r22, r12
    29e4:	80 e2       	ldi	r24, 0x20	; 32
    29e6:	90 e0       	ldi	r25, 0x00	; 0
    29e8:	0e 94 18 15 	call	0x2a30	; 0x2a30 <fputc>
    29ec:	2a 94       	dec	r2
    29ee:	f6 cf       	rjmp	.-20     	; 0x29dc <vfprintf+0x39a>
    29f0:	f6 01       	movw	r30, r12
    29f2:	86 81       	ldd	r24, Z+6	; 0x06
    29f4:	97 81       	ldd	r25, Z+7	; 0x07
    29f6:	02 c0       	rjmp	.+4      	; 0x29fc <vfprintf+0x3ba>
    29f8:	8f ef       	ldi	r24, 0xFF	; 255
    29fa:	9f ef       	ldi	r25, 0xFF	; 255
    29fc:	2b 96       	adiw	r28, 0x0b	; 11
    29fe:	e2 e1       	ldi	r30, 0x12	; 18
    2a00:	0c 94 ce 15 	jmp	0x2b9c	; 0x2b9c <__epilogue_restores__>

00002a04 <strnlen_P>:
    2a04:	fc 01       	movw	r30, r24
    2a06:	05 90       	lpm	r0, Z+
    2a08:	61 50       	subi	r22, 0x01	; 1
    2a0a:	70 40       	sbci	r23, 0x00	; 0
    2a0c:	01 10       	cpse	r0, r1
    2a0e:	d8 f7       	brcc	.-10     	; 0x2a06 <strnlen_P+0x2>
    2a10:	80 95       	com	r24
    2a12:	90 95       	com	r25
    2a14:	8e 0f       	add	r24, r30
    2a16:	9f 1f       	adc	r25, r31
    2a18:	08 95       	ret

00002a1a <strnlen>:
    2a1a:	fc 01       	movw	r30, r24
    2a1c:	61 50       	subi	r22, 0x01	; 1
    2a1e:	70 40       	sbci	r23, 0x00	; 0
    2a20:	01 90       	ld	r0, Z+
    2a22:	01 10       	cpse	r0, r1
    2a24:	d8 f7       	brcc	.-10     	; 0x2a1c <strnlen+0x2>
    2a26:	80 95       	com	r24
    2a28:	90 95       	com	r25
    2a2a:	8e 0f       	add	r24, r30
    2a2c:	9f 1f       	adc	r25, r31
    2a2e:	08 95       	ret

00002a30 <fputc>:
    2a30:	0f 93       	push	r16
    2a32:	1f 93       	push	r17
    2a34:	cf 93       	push	r28
    2a36:	df 93       	push	r29
    2a38:	fb 01       	movw	r30, r22
    2a3a:	23 81       	ldd	r18, Z+3	; 0x03
    2a3c:	21 fd       	sbrc	r18, 1
    2a3e:	03 c0       	rjmp	.+6      	; 0x2a46 <fputc+0x16>
    2a40:	8f ef       	ldi	r24, 0xFF	; 255
    2a42:	9f ef       	ldi	r25, 0xFF	; 255
    2a44:	2c c0       	rjmp	.+88     	; 0x2a9e <fputc+0x6e>
    2a46:	22 ff       	sbrs	r18, 2
    2a48:	16 c0       	rjmp	.+44     	; 0x2a76 <fputc+0x46>
    2a4a:	46 81       	ldd	r20, Z+6	; 0x06
    2a4c:	57 81       	ldd	r21, Z+7	; 0x07
    2a4e:	24 81       	ldd	r18, Z+4	; 0x04
    2a50:	35 81       	ldd	r19, Z+5	; 0x05
    2a52:	42 17       	cp	r20, r18
    2a54:	53 07       	cpc	r21, r19
    2a56:	44 f4       	brge	.+16     	; 0x2a68 <fputc+0x38>
    2a58:	a0 81       	ld	r26, Z
    2a5a:	b1 81       	ldd	r27, Z+1	; 0x01
    2a5c:	9d 01       	movw	r18, r26
    2a5e:	2f 5f       	subi	r18, 0xFF	; 255
    2a60:	3f 4f       	sbci	r19, 0xFF	; 255
    2a62:	31 83       	std	Z+1, r19	; 0x01
    2a64:	20 83       	st	Z, r18
    2a66:	8c 93       	st	X, r24
    2a68:	26 81       	ldd	r18, Z+6	; 0x06
    2a6a:	37 81       	ldd	r19, Z+7	; 0x07
    2a6c:	2f 5f       	subi	r18, 0xFF	; 255
    2a6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2a70:	37 83       	std	Z+7, r19	; 0x07
    2a72:	26 83       	std	Z+6, r18	; 0x06
    2a74:	14 c0       	rjmp	.+40     	; 0x2a9e <fputc+0x6e>
    2a76:	8b 01       	movw	r16, r22
    2a78:	ec 01       	movw	r28, r24
    2a7a:	fb 01       	movw	r30, r22
    2a7c:	00 84       	ldd	r0, Z+8	; 0x08
    2a7e:	f1 85       	ldd	r31, Z+9	; 0x09
    2a80:	e0 2d       	mov	r30, r0
    2a82:	09 95       	icall
    2a84:	89 2b       	or	r24, r25
    2a86:	e1 f6       	brne	.-72     	; 0x2a40 <fputc+0x10>
    2a88:	d8 01       	movw	r26, r16
    2a8a:	16 96       	adiw	r26, 0x06	; 6
    2a8c:	8d 91       	ld	r24, X+
    2a8e:	9c 91       	ld	r25, X
    2a90:	17 97       	sbiw	r26, 0x07	; 7
    2a92:	01 96       	adiw	r24, 0x01	; 1
    2a94:	17 96       	adiw	r26, 0x07	; 7
    2a96:	9c 93       	st	X, r25
    2a98:	8e 93       	st	-X, r24
    2a9a:	16 97       	sbiw	r26, 0x06	; 6
    2a9c:	ce 01       	movw	r24, r28
    2a9e:	df 91       	pop	r29
    2aa0:	cf 91       	pop	r28
    2aa2:	1f 91       	pop	r17
    2aa4:	0f 91       	pop	r16
    2aa6:	08 95       	ret

00002aa8 <__ultoa_invert>:
    2aa8:	fa 01       	movw	r30, r20
    2aaa:	aa 27       	eor	r26, r26
    2aac:	28 30       	cpi	r18, 0x08	; 8
    2aae:	51 f1       	breq	.+84     	; 0x2b04 <__ultoa_invert+0x5c>
    2ab0:	20 31       	cpi	r18, 0x10	; 16
    2ab2:	81 f1       	breq	.+96     	; 0x2b14 <__ultoa_invert+0x6c>
    2ab4:	e8 94       	clt
    2ab6:	6f 93       	push	r22
    2ab8:	6e 7f       	andi	r22, 0xFE	; 254
    2aba:	6e 5f       	subi	r22, 0xFE	; 254
    2abc:	7f 4f       	sbci	r23, 0xFF	; 255
    2abe:	8f 4f       	sbci	r24, 0xFF	; 255
    2ac0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ac2:	af 4f       	sbci	r26, 0xFF	; 255
    2ac4:	b1 e0       	ldi	r27, 0x01	; 1
    2ac6:	3e d0       	rcall	.+124    	; 0x2b44 <__ultoa_invert+0x9c>
    2ac8:	b4 e0       	ldi	r27, 0x04	; 4
    2aca:	3c d0       	rcall	.+120    	; 0x2b44 <__ultoa_invert+0x9c>
    2acc:	67 0f       	add	r22, r23
    2ace:	78 1f       	adc	r23, r24
    2ad0:	89 1f       	adc	r24, r25
    2ad2:	9a 1f       	adc	r25, r26
    2ad4:	a1 1d       	adc	r26, r1
    2ad6:	68 0f       	add	r22, r24
    2ad8:	79 1f       	adc	r23, r25
    2ada:	8a 1f       	adc	r24, r26
    2adc:	91 1d       	adc	r25, r1
    2ade:	a1 1d       	adc	r26, r1
    2ae0:	6a 0f       	add	r22, r26
    2ae2:	71 1d       	adc	r23, r1
    2ae4:	81 1d       	adc	r24, r1
    2ae6:	91 1d       	adc	r25, r1
    2ae8:	a1 1d       	adc	r26, r1
    2aea:	20 d0       	rcall	.+64     	; 0x2b2c <__ultoa_invert+0x84>
    2aec:	09 f4       	brne	.+2      	; 0x2af0 <__ultoa_invert+0x48>
    2aee:	68 94       	set
    2af0:	3f 91       	pop	r19
    2af2:	2a e0       	ldi	r18, 0x0A	; 10
    2af4:	26 9f       	mul	r18, r22
    2af6:	11 24       	eor	r1, r1
    2af8:	30 19       	sub	r19, r0
    2afa:	30 5d       	subi	r19, 0xD0	; 208
    2afc:	31 93       	st	Z+, r19
    2afe:	de f6       	brtc	.-74     	; 0x2ab6 <__ultoa_invert+0xe>
    2b00:	cf 01       	movw	r24, r30
    2b02:	08 95       	ret
    2b04:	46 2f       	mov	r20, r22
    2b06:	47 70       	andi	r20, 0x07	; 7
    2b08:	40 5d       	subi	r20, 0xD0	; 208
    2b0a:	41 93       	st	Z+, r20
    2b0c:	b3 e0       	ldi	r27, 0x03	; 3
    2b0e:	0f d0       	rcall	.+30     	; 0x2b2e <__ultoa_invert+0x86>
    2b10:	c9 f7       	brne	.-14     	; 0x2b04 <__ultoa_invert+0x5c>
    2b12:	f6 cf       	rjmp	.-20     	; 0x2b00 <__ultoa_invert+0x58>
    2b14:	46 2f       	mov	r20, r22
    2b16:	4f 70       	andi	r20, 0x0F	; 15
    2b18:	40 5d       	subi	r20, 0xD0	; 208
    2b1a:	4a 33       	cpi	r20, 0x3A	; 58
    2b1c:	18 f0       	brcs	.+6      	; 0x2b24 <__ultoa_invert+0x7c>
    2b1e:	49 5d       	subi	r20, 0xD9	; 217
    2b20:	31 fd       	sbrc	r19, 1
    2b22:	40 52       	subi	r20, 0x20	; 32
    2b24:	41 93       	st	Z+, r20
    2b26:	02 d0       	rcall	.+4      	; 0x2b2c <__ultoa_invert+0x84>
    2b28:	a9 f7       	brne	.-22     	; 0x2b14 <__ultoa_invert+0x6c>
    2b2a:	ea cf       	rjmp	.-44     	; 0x2b00 <__ultoa_invert+0x58>
    2b2c:	b4 e0       	ldi	r27, 0x04	; 4
    2b2e:	a6 95       	lsr	r26
    2b30:	97 95       	ror	r25
    2b32:	87 95       	ror	r24
    2b34:	77 95       	ror	r23
    2b36:	67 95       	ror	r22
    2b38:	ba 95       	dec	r27
    2b3a:	c9 f7       	brne	.-14     	; 0x2b2e <__ultoa_invert+0x86>
    2b3c:	00 97       	sbiw	r24, 0x00	; 0
    2b3e:	61 05       	cpc	r22, r1
    2b40:	71 05       	cpc	r23, r1
    2b42:	08 95       	ret
    2b44:	9b 01       	movw	r18, r22
    2b46:	ac 01       	movw	r20, r24
    2b48:	0a 2e       	mov	r0, r26
    2b4a:	06 94       	lsr	r0
    2b4c:	57 95       	ror	r21
    2b4e:	47 95       	ror	r20
    2b50:	37 95       	ror	r19
    2b52:	27 95       	ror	r18
    2b54:	ba 95       	dec	r27
    2b56:	c9 f7       	brne	.-14     	; 0x2b4a <__ultoa_invert+0xa2>
    2b58:	62 0f       	add	r22, r18
    2b5a:	73 1f       	adc	r23, r19
    2b5c:	84 1f       	adc	r24, r20
    2b5e:	95 1f       	adc	r25, r21
    2b60:	a0 1d       	adc	r26, r0
    2b62:	08 95       	ret

00002b64 <__prologue_saves__>:
    2b64:	2f 92       	push	r2
    2b66:	3f 92       	push	r3
    2b68:	4f 92       	push	r4
    2b6a:	5f 92       	push	r5
    2b6c:	6f 92       	push	r6
    2b6e:	7f 92       	push	r7
    2b70:	8f 92       	push	r8
    2b72:	9f 92       	push	r9
    2b74:	af 92       	push	r10
    2b76:	bf 92       	push	r11
    2b78:	cf 92       	push	r12
    2b7a:	df 92       	push	r13
    2b7c:	ef 92       	push	r14
    2b7e:	ff 92       	push	r15
    2b80:	0f 93       	push	r16
    2b82:	1f 93       	push	r17
    2b84:	cf 93       	push	r28
    2b86:	df 93       	push	r29
    2b88:	cd b7       	in	r28, 0x3d	; 61
    2b8a:	de b7       	in	r29, 0x3e	; 62
    2b8c:	ca 1b       	sub	r28, r26
    2b8e:	db 0b       	sbc	r29, r27
    2b90:	0f b6       	in	r0, 0x3f	; 63
    2b92:	f8 94       	cli
    2b94:	de bf       	out	0x3e, r29	; 62
    2b96:	0f be       	out	0x3f, r0	; 63
    2b98:	cd bf       	out	0x3d, r28	; 61
    2b9a:	09 94       	ijmp

00002b9c <__epilogue_restores__>:
    2b9c:	2a 88       	ldd	r2, Y+18	; 0x12
    2b9e:	39 88       	ldd	r3, Y+17	; 0x11
    2ba0:	48 88       	ldd	r4, Y+16	; 0x10
    2ba2:	5f 84       	ldd	r5, Y+15	; 0x0f
    2ba4:	6e 84       	ldd	r6, Y+14	; 0x0e
    2ba6:	7d 84       	ldd	r7, Y+13	; 0x0d
    2ba8:	8c 84       	ldd	r8, Y+12	; 0x0c
    2baa:	9b 84       	ldd	r9, Y+11	; 0x0b
    2bac:	aa 84       	ldd	r10, Y+10	; 0x0a
    2bae:	b9 84       	ldd	r11, Y+9	; 0x09
    2bb0:	c8 84       	ldd	r12, Y+8	; 0x08
    2bb2:	df 80       	ldd	r13, Y+7	; 0x07
    2bb4:	ee 80       	ldd	r14, Y+6	; 0x06
    2bb6:	fd 80       	ldd	r15, Y+5	; 0x05
    2bb8:	0c 81       	ldd	r16, Y+4	; 0x04
    2bba:	1b 81       	ldd	r17, Y+3	; 0x03
    2bbc:	aa 81       	ldd	r26, Y+2	; 0x02
    2bbe:	b9 81       	ldd	r27, Y+1	; 0x01
    2bc0:	ce 0f       	add	r28, r30
    2bc2:	d1 1d       	adc	r29, r1
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	f8 94       	cli
    2bc8:	de bf       	out	0x3e, r29	; 62
    2bca:	0f be       	out	0x3f, r0	; 63
    2bcc:	cd bf       	out	0x3d, r28	; 61
    2bce:	ed 01       	movw	r28, r26
    2bd0:	08 95       	ret

00002bd2 <_exit>:
    2bd2:	f8 94       	cli

00002bd4 <__stop_program>:
    2bd4:	ff cf       	rjmp	.-2      	; 0x2bd4 <__stop_program>
